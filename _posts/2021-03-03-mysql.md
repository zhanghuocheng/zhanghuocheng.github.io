---
layout: pages
---

### mysql基本背景概念

```
死锁定义：A B 事务先后修改 3 4 两条数据。A先对3修改，B先对4进行修改。
死锁的原因：1 数据冲突 2 存储引擎的实现方式
死锁监测
死锁超时机制

InnoDb死锁的处理方式：将持有最少行级排他锁的事务进行回滚。

应用程序面对死锁的处理方式：重新执行因死锁回滚的事务

myIsam 不支持事务和崩溃后恢复  设计简单 数据紧密格式存储

mysql复制
1 主库把日志存储到bin log 
2 从库将主库的日志复制到自己的中继日志中（Relay log）
3 备库读取日志中的事件，放到自己的数据库上

聚簇索引
定义:并不是一种单独的索引类型，而是一种数据存储方式。
innoDB聚簇索引：同一个结构中保存了B-tree的索引和数据行。
一个表只能有一个聚簇索引


B+树不是二叉树，是由二叉树演变而来
B+树的演变过程：二叉查找树 平衡二叉树 B树演变而来
二叉查找树：性质右边大于跟大于左边 缺点 线性的查询效率低
平衡二叉树：定义满足二叉查找树，树的高度差<=1   缺点 插入维护成本高 需要左旋和右旋


B+树原理：只能根据索引找到数据所在的页
定义：B树+索引顺序访问 

B+树索引分为聚集索引和辅助聚集索引

聚集和非聚集的区别是叶子节点是否放一整行信息

聚集：存放 非聚集不存放

非聚集：辅助索引 不存放数据，只存放索引+书签 ，通过书签可以找到这个数据



```

![image-20210524144354667](/images/image-20210524144354667.png)

### mysql索引

```
背景 
1 读取内存比磁盘快10w倍
2 百万条数据只需走三次io，只需要查询三次

索引的分类：1 hash  2 B tree树  3 空间数据索引 r_tree -用于存储地理位置（myisam引擎）4 全文索引 

hash
定义：使用hash算法实现，索引只包含hash值和行指针
缺点：1 不是按照顺序存储，无法排序

全文索引：基于关键字查询，而不是根据where条件

主键索引 不能为空 不能重复

b+树  
数据存放叶子节点，非叶子节点只存储指引搜索方向的数据项。
性质1 树的高度=查询数据io的次数-->创建int 四个字节，bigint8个字节，磁盘快=数据页的大小固定 索引要尽可能小，让树的高度低
性质2 最左匹配特性

索引设计原则 1 最左匹配 2 区分度高 3 索引不参与计算 4 尽量扩展索引 

1.最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(>、<、between、like)就停止匹配，比如a = 1 and b = 2 and c > 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。

2.=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。

3.尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。

4.索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。

5.尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。

执行计划  查看rows的条数



聚簇索引
```

```
https://cloud.tencent.com/developer/article/1541265
```

```
1.    mysql都有什么锁
MySQL有三种锁的级别：页级、表级、行级。
表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。
行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。
页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
算法：
next KeyLocks锁，同时锁住记录(数据)，并且锁住记录前面的Gap    
Gap锁，不锁记录，仅仅记录前面的Gap
Recordlock锁（锁数据，不锁Gap）
所以其实 Next-KeyLocks=Gap锁+ Recordlock锁

```



### mysql事务

```
特性：持久 隔离 原子，一致
隔离界别：读未提交，读提交，可重复读  串行化

现象
脏读：一个事务未提交的数据对另一个事务可见  读未提交
不可重复读：update 一个事务在另一个事务操作前后读取同一条数，数据值不同。 读提交
幻读 insert 一个事务的插入，会对其他事务的读产生影响。具体的场景：select id=1，没有，然后在插入 发现插入异常 已经有了。

隔离界别的数据库理论实现
    读未提交  写加锁 读不加锁
    读提交 写加锁 读 只在sql执行加锁 
    可重复读 写加锁 读加锁直到事务结束后释放
    串行化 事务串行化执行

mysql的是实现
    读未提交  写加锁 读不加锁
    读提交  mvcc解决不可重复读
    可重复读 通过mvcc+行锁/间隙锁解决幻读 
    串行化 事务串行化执行
    
mvcc 多版本并发控制-innodb
mvcc是利用在每条数据后面加了隐藏的两列（创建版本号和删除版本号）当执行查询的时, 当前查询版本号>= 创建版本号 当前版本号 <删除版本号 , MVCC可以在大多数情况下代替行级锁,使用MVCC,能降低其系统开销。

作用的事务隔离级别：读提交和可重复读



幻读的解决详细过程

通过对 select 操作手动加 行X锁（SELECT ... FOR UPDATE 这也正是 SERIALIZABLE 隔离级别下会隐式为你做的事情），同时还需要知道，即便当前记录不存在，比如 id=1 是不存在的，当前事务也会获得一把记录锁（因为InnoDB的行锁锁定的是索引，故记录实体存在与否没关系，存在就加 行X锁，不存在就加 next-key lock间隙X锁），其他事务则无法插入此索引的记录，故杜绝了幻读。

快照读和当前读
分2种，快照读-读历史数据，当前读读当前数据 查询使用快照读，删除 修改使用当前读
(1)快照读(mvcc) 普通的 select 就是快照读。将历史数据存一份快照，所以其他事务增加与删除数据，对于当前事务来说是不可见的。事务每次取数据的时候都会取创建版本<当前事务的数据，以及删除版本号码>当前版本的数据。

```



| 事务隔离级别\现象 | 脏读         | 不可重复读update delete | 幻读 insert |
| ----------------- | ------------ | ----------------------- | ----------- |
| 读未提交          | Y            | Y                       | Y           |
| 读提交            | 1 如何解决的 | Y                       | Y           |
| 可重复读          | 2 如何解决的 | 3 如何解决的            | Y           |
| 串行化            |              |                         |             |

```
理论
在事务中存在以下几种隔离级别：
- 读未提交(Read Uncommitted)：写排他锁，读不加锁
- 读已提交(Read Committed)：解决了脏读问题。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。这可以通过“瞬间共享读锁”和“排他写锁”实现， 即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成后立刻释放 S 锁，不用等到事务结束。
- 可重复读取(Repeatable Read)：禁止不可重复读取和脏读取，但是有时可能出现幻读数据。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。Mysql默认使用该隔离级别。这可以通过“共享读锁”和“排他写锁”实现，即事务需要对某些数据进行修改必须对这些数据加 X 锁，读数据时需要加上 S 锁，当数据读取完成并不立刻释放 S 锁，而是等到事务结束后再释放。
- 串行化(Serializable)：解决了幻读的问题的。提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，不能并发执行。仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。
```



```
 mysql 的sql执行过程
 mysql的bin log
```

## mysql 的sql执行过程



```
1 连接
2 缓存（8.0去掉）
3 分析 语法分析
4 优化 是否走索引执行策略
5 执行 （验证权限）
```

```

1. 优化更需要优化的 Query;
2. 定位优化对象的性能瓶颈;
3. 明确的优化目标;
4. 从 Explain 入手;
5. 多使用 profile
6. 永远用小结果集驱动大的结果集;
7. 尽可能在索引中完成排序;
8. 只取出自己需要的 Columns;
9. 仅仅使用最有效的过滤条件;
10. 尽可能避免复杂的Join和子查询;

```



索引的区别hash和B+树

```
hash 
优点：快
缺点：1不支持范围查询 2 不支持排序 3 不用部分索引查询 4  hash冲突需要表扫描



```





sql优化排查

```
1 io还是cpu  还是数据运算（分组排序） 在哪方面耗时过多

2 通过 PROFILING  找到sql
```



###  mysql的bin log