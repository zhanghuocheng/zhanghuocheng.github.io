---
layout: page
typora-copy-images-to: ..\images
---

*  目录
{:toc}

### mysql 45 讲

#### 1 基础架构-一条sql查询语句是如何执行的

###### 1.1 整体架构

![image-20211124073719937](/images/image-20211124073719937.png)

###### 1.2 连接器

```
1 连接命令：mysql -h$ip -P$port -u$user -p //建议密码不要跟在-p后面 ，产生密码泄漏？
	密码错误 -Access denied for user
2 show processlist 查看连接；连接默认时间是8小时，wait_timeout 参数控制
	连接断开的错误
3 连接失效 再查询 报错 Lost connection to MySQL server during query -->解决办法--->再建立连接
4 长连接使用过多-->内存涨得快---原因-->执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放----解决办法--->
	4.1 定期断开，遇到大查询 断开连接 重连
	4.2 mysql version>=5.7 mysql_reset_connection 重制连接
```



###### 1.2 查询缓存

```
1 查询缓存 缓存的存储 key(sql) value (ret)  一般不开启-->查询缓存往往弊大于利 -->表更新，缓存失效
2 使用场景，静态表，几乎不更新的
3 设置  query_cache_type  DEMAND 默认sql不查缓存
4 8.0废弃查询缓存

```

####### 1.3  分析器

```
1 词法分析 关键字拼写对不对
2 语法分析 关键字排列是否正确
```

###### 1.4 优化器

```
1 选择索引决定权 
2 表的关联顺序  select * from t1 join t2 where t1.a=t2.b
```

###### 1.5 执行器 select * from table where id >90

```
1 权限验证
2 打开表，根据表的定义，执行引擎提供的接口

如果表没有索引的执行过程
	1 调用引擎接口取表的第一行。判断id是否大于90 
	2 调用引擎接口取表的下一行。判断id是否大于90 
	3 返回满足上面的结果集
	
慢查sql rows_examined 这个字段表示一次查询扫描了多少行 注意 ：在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此引擎扫描行数跟rows_examined并不是完全相同的
```





#### 2 日志系统--一条sql 更新语句是如何执行的

```
mysql可以恢复到半个月内 任意一秒的状态
```

2.1  redo log  (重做日志) -InnoDB独有 引擎层

```
WAL技术，WAL的全称是Write-Ahead Logging 先写进日志 再进磁盘
crash-safe  就是在关机之前 把 中间缓存的日志全部写到文件
```

2.2 bin log  (归档日志)- server层



2.3 redo log  &&bin log区别

```
1 redo log是InnoDB引擎特有的；binlog是MySQL的Server层实现的，所有引擎都可以使用。

2 redo log是物理日志，记录的是“在某个数据页上做了什么修改”；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如“给ID=2这一行的c字段加1 ”。

3 redo log是循环写的，空间固定会用完；binlog是可以追加写入的。“追加写”是指binlog文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
```



#### 03 | 事务隔离：为什么你改了我还看不见？

1 特性：

ACID :原子性、一致性、隔离性、持久性



![img]\images\7dea45932a6b722eb069d2264d0066f8.png)

```
我们来看看在不同的隔离级别下，事务A会有哪些不同的返回结果，也就是图里面V1、V2、V3的返回值分别是什么。

若隔离级别是“读未提交”， 则V1的值就是2。这时候事务B虽然还没有提交，但是结果已经被A看到了。因此，V2、V3也都是2。
若隔离级别是“读提交”，则V1是1，V2的值是2。事务B的更新在提交后才能被A看到。所以， V3的值也是2。
若隔离级别是“可重复读”，则V1、V2是1，V3是2。之所以V2还是1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
若隔离级别是“串行化”，则在事务B执行“将1改成2”的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。所以从A的角度看， V1、V2值是1，V3的值是2。
```



| 事务隔离级别 | 问题       | 解决办法              | mysql默认 | oracle默认 |      |
| ------------ | ---------- | --------------------- | --------- | ---------- | ---- |
| 读未提交     | 脏读       | 无视图概念            |           |            |      |
| 读提交       | 不可重复读 | 在sql之前之前创建视图 |           | √          |      |
| 可重复读     | 幻读       | 在事务启动时创建视图  | √         |            |      |
| 串行化       |            | 对读写进行枷锁        |           |            |      |

```
1 读未提交是指:一个事务还没提交时，它做的变更就能被别的事务看到。
2 读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
3 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
4 串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

脏读:  你读了比人乜有提交的数据
不可重复读：同一个事务，读一个数据2次读的结果不一致
幻读： 幻读是在一个事务执行时，有其他的事务insert  。幻读是对insert 操作 产生的幻觉
```



关于事务的参数配置

```
1 配置事务隔离级别 将启动参数 transaction-isolation的值设置成READ-COMMITTED 
2 查看事务的隔离级别 show variables like 'transaction_isolation';
```



长事务缺点

```
视图 回滚日志 --大量占用存储
```



事务启动方式 、

```
set autocommit=0，这个线程的自动提交关掉

commit work and chain  结束当前事务，开启下一个事务
information_schema  innodb_trx 长事务的表和库

查询超过60s的长事务
select * from information_schema.innodb_trx where TIME_TO_SEC(timediff(now(),trx_started))>60

```

#### 04 深入浅出索引-上





### 1  基础架构 

![1 mysql基础架构](/images/1 mysql基础架构.png)

### 2  日志系统

![2 mysql日志系统](/images/2 mysql日志系统.png)

### 3 事务隔离

![3 mysql 事务隔离](/images/3 mysql 事务隔离.png)

### 4 索引

![5 mysql深入浅出索引](/images/5 mysql深入浅出索引.png)

##### 5 全局锁&&表锁

![6 mysql全局锁&表锁](/images/6 mysql全局锁&表锁.png)

### 6 行锁

![7 mysql 行锁](/images/7 mysql 行锁.png)
