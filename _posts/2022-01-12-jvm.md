---
layout: page
---

[TOC]

# jvm总结

```
此图介绍jvm核心概念及其问题
```

![image-20220308192511544](/images/image-20220308192511544.png)

## 1 java类加载

1. 加载 分三步，1 根据包名+类名加载文件二进制文件 2 存储在方法区 3 生成类的class实例

   ````
   双亲委派
   
   如何打破
   
   是通过重写ClassLoader#loadClass和ClassLoader#findClass 实现的。可以看图中的WebAppClassLoader，它加载自己目录下的.class文件，并不会传递给父类的加载器。但是，它却可以使用 SharedClassLoader 所加载的类，实现了共享和分离的功能。
   
   
   接口加载过程与类加载过程稍有不同。
   
   当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。
   
   
   #####10 类加载器
   
   #######判断类是否相等 
   
   ```
   这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。
   ```
   
   #######双亲委派模型是啥 ？如何打破
   
   ```
   1 打破案例 jdbc tomcat
   
   是通过重写ClassLoader#loadClass和ClassLoader#findClass 实现的。可以看图中的WebAppClassLoader，它加载自己目录下的.class文件，并不会传递给父类的加载器。但是，它却可以使用 SharedClassLoader 所加载的类，实现了共享和分离的功能。
   ```
   
   #######加载器种类
   
   ```
   系统提供了 3 种类加载器：
   
   启动类加载器（Bootstrap ClassLoader）： 负责将存放在 <JAVA_HOME>\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。
   
   扩展类加载器（Extension ClassLoader）： 负责加载 <JAVA_HOME>\lib\ext 目录中的所有类库，开发者可以直接使用扩展类加载器。
   
   应用程序类加载器（Application ClassLoader）： 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
   ```
   
   
   
   #####jvm 03-02
   
   #######类的唯一性
   
   ```
   类的唯一性是由类加载器实例以及类的全名一同确定的。即便是同一串字节流，经由不同的类加载器加载，也会得到两个不同的类。在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。
   
   ````
   
2. #######验证   文件格式 元数据 字节码 符号引用

   ```
   #######验证的过程
   
   - 文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
     - 是否以魔数 0XCAFEBABE 开头。
     - 主次版本号是否在当前虚拟机处理范围内。
     - 常量池是否有不被支持的常量类型。
     - 指向常量的索引值是否指向了不存在的常量。
     - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据。
   ```

   

3. #######准备   为静态变量分配内存并设置0值，

4. #######解析

```
#######解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
```



1. #######初始化

#####2 java内存模型

#######java内存模型

![image-20220225110539266](/images/image-20220225110539266.png)

####### 方法区

```
存放：已经被虚拟机加载的类信息 常量 静态变量 即时编译器编译后的代码
特点：线程共享 永久代 内存回收效率低

废弃常量
	判定方式 不被引用
无用的类
	该类的所有对象都已经被清除
  加载该类的 ClassLoader 已经被回收
  该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  
  一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。
```

#######堆

```
 堆可以分为Eden区, from Survior ，to Survivor 老年代

新生代和老年代
	1 新生代：老年代默认1:2, JVM 调参数，XX:NewRatio=2
	2 Eden 空间和另外两个 Survivor 空间缺省所占的比例是：8:1:1
	
	new 的对象先放在 Eden 区，大小有限制
如果创建新对象时，Eden 空间填满了，就会触发 Minor GC，将 Eden 不再被其他对象引用的对象进行销毁，再加载新的对象放到 Eden 区，特别注意的是 Survivor 区满了是不会触发 Minor GC 的，而是 Eden 空间填满了，Minor GC 才顺便清理 Survivor 区
将 Eden 中剩余的对象移到 Survivor0 区
再次触发垃圾回收，此时上次 Survivor 下来的，放在 Survivor0 区的，如果没有回收，就会放到 Survivor1 区
再次经历垃圾回收，又会将幸存者重新放回 Survivor0 区，依次类推
默认是 15 次的循环，超过 15 次，则会将幸存者区幸存下来的转去老年区 jvm 参数设置次数 : -XX:MaxTenuringThreshold=N 进行设置
频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集
```

#######程序计数器

```
作用 记录当前线程执行的位置
特点:唯一不会发生OutOfMemoryError的区域
```

#######java虚拟机栈

```
特点：StackOverFlowError，OutOfMemoryError。是否允许动态扩展，栈深度异常-->StackOverFlowError,内存问题-
```

#######本地方法栈

```

```

####### 逃逸分析

```
当一个对象在方法中被定义后，它可能被外部方法所引用，如作为调用参数传递到其他地方中，称为方法逃逸
再如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸

在编译期间，如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。
jvm 参数设置，-XX:+DoEscapeAnalysis ：开启逃逸分析 ，-XX:-DoEscapeAnalysis ： 关闭逃逸分析
从 jdk 1.7 开始已经默认开始逃逸分析。
```



#######TLAB

```
TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区，是属于 Eden 区的，这是一个线程专用的内存分配区域，线程私有,默认开启的（当然也不是绝对的，也要看哪种类型的虚拟机）

堆上申请内存使用CAS,
-XX:+UseTLAB 使用 TLAB,-XX:+TLABSize 设置 TLAB 大小
```

#######四种引用方式

```
- 强引用：创建一个对象并把这个对象赋给一个引用变量 , 普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收，jvm 即使抛出 OOM，可以将引用赋值为 null，那么它所指向的对象就会被垃圾回收
- 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用
- 弱引用：非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。
- 虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
```

#######直接内存

```
定义:java虚拟机内存之外的内存
应用：NIO通过 DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率

直接内存与堆内存比较
		申请直接内存更消耗性能
		读取直接内存性能更好
		
-Xmx这个参数的值包含直接内存


直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。

垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “`System.gc()`”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。
```

#####4 垃圾收集器

#######对象头信息

```
对象头 :
    哈希码
    GC 分代年龄
    锁状态标志
    线程持有的锁
    偏向线程 ID
    偏向时间戳
    如果对象是一个数组，那么对象头还会包括数组长度
    实例数据 父类和本类的成员变量
    对齐数据 确保对象的总长度是8字节的倍数
```

#######对象的创建过程

````
1 类加载 
2 分配
	指针碰撞：当内存比较规整，空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大					小一样的距离，这种分配方式称为“指针碰撞”。
	空闲列表： Java 堆中内存并不规整，VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划						分给对象实例。这种方式称为“空闲列表”。
3 初始化 1成员变量初值，设置对象头信息，调用构造函数初始化

java 创建对象的方式

```
 new 语句之外，我们还可以通过反射机制、Object.clone 方法、反序列化以及 Unsafe.allocateInstance 方法来新建对象。
```


````

![image-20220225155705041](/images/image-20220225155705041.png)

#######对象的访问方式

```
内存分配  对象的存储空间都是在堆中分配的，对象的引用却是在堆栈中分配的

句柄访问方式
直接指针访问方式
区别
HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要额外的策略来存储对象在方法区中类信息的地址。
```

![image-20220225162642266](/images/image-20220225162642266.png)

![image-20220225162650101](/images/image-20220225162650101.png)



#######怎么看当前使用哪种垃圾收集

```
-XX:+PrintCommandLineFlags 
通过gc日志 

通过jconsole 
```

#######垃圾回收算法

```
标记-清除
	过程:使用可达性分析标记，清除
	不足：效率问题，标记和清除2个动作效率低;空间问题:碎片
	
复制算法(新生代)
	过程：把内存分为2块，将存货对象复制到另一块，然后清除所有对象。
	优缺点：不会又碎片，但是空间利用率为50%

改进 新生代的内存结构，Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。

问题:不能保证回收的只有10%对象，需要依赖老年代进行分配担保

分配担保
为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。

新生代：复制算法
老年代：标记-清除算法、标记-整理算法s

1 对象可能分配在栈 堆 年轻代 老年代上 取决于垃圾回收器的组合和相关参数配置 逃逸可以是对象优先分配在栈上

2  大对象优先分配在Eden(E等)中
```

````
gc root

```
Java 方法栈桢中的局部变量；
已加载类的静态变量；
JNI handles；
已启动且未停止的 Java 线程。
````



#######**Minor GC** vs **Major GC**/**Full GC**：

````
**Minor (ˈmaɪnər) GC** vs **Major(ˈmeɪdʒər) GC**/**Full GC**：
大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。

**Minor (ˈmaɪnər) GC** vs **Major(ˈmeɪdʒər) GC**/**Full GC**：

新生代：**Minor (ˈmaɪnər) GC
老年代：Major GC  比Minor的慢10倍以上 


 在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。


 对象直接进入老年代情况

1  大对象直接进入老年代  因为大对象发生分配担保的概率很大，分配担保会导致效率低下
-XX:PretenureSizeThreshold 参数配置 大于这个配置称为大对象

2 新生代存活次数超过  XXMaxTenuringThreshold配置 ，进入老年代

3 动态对象年龄判断
	如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 >= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。
	
	
full gc 触发的条件

1 System.gc()  通过 DisableExplicitGC  参数禁止调用
2 老年代空间不足触发，如果触发后还不足，OutOfMemoryError Java heap space
3 永久代空间不足，方法区空间不足 full gc，触发后还是不足 -->OutOfMemoryError: PermGen space
4 CMS GC是出现promotion failed(担保失败) 和 concurrent mode failure(老年代空间不足)
5 统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间

minor gc

```
Java 虚拟机会记录 Survivor 区中的对象一共被来回复制了几次。如果一个对象被复制的次数为 15（对应虚拟机参数 -XX:+MaxTenuringThreshold），那么该对象将被晋升（promote）至老年代。另外，如果单个 Survivor 区已经被占用了 50%（对应虚拟机参数 -XX:TargetSurvivorRatio），那么较高复制次数的对象也会被晋升至老年代。
```
新生代的垃圾回收

```
针对新生代的垃圾回收器共有三个：Serial，Parallel Scavenge 和 Parallel New。这三个采用的都是标记 - 复制算法。其中，Serial 是一个单线程的，Parallel New 可以看成 Serial 的多线程版本。Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。此外，Parallel Scavenge 不能与 CMS 一起使用。
```

老年代的垃圾回收

```
针对老年代的垃圾回收器也有三个：刚刚提到的 Serial Old 和 Parallel Old，以及 CMS。Serial Old 和 Parallel Old 都是标记 - 压缩算法。同样，前者是单线程的，而后者可以看成前者的多线程版本。
```

cms

```
CMS 采用的是标记 - 清除算法，并且是并发的。除了少数几个操作需要 Stop-the-world 之外，它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。由于 G1 的出现，CMS 在 Java 9 中已被废弃 [3]。
```



G1

```
G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。

G1 能够针对每个细分的区域来进行垃圾回收。在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。

即将到来的 Java 11 引入了 ZGC，宣称暂停时间不超过 10ms。如果你感兴趣的话，可参考 R 大的这篇文章 [4]。



#######方法内联

```
我多次提到了方法内联这项技术。它指的是：在编译过程中遇到方法调用时，将目标方法的方法体纳入编译范围之中，并取代原方法调用的优化手段。

内联规则 如自动拆箱总会被内联、Throwable 类的方法不能被其他类中的方法所内联，你可以直接参考JDK 的源代码。）

首先，由 -XX:CompileCommand 中的 inline 指令指定的方法，以及由 @ForceInline 注解的方法（仅限于 JDK 内部方法），会被强制内联。 而由 -XX:CompileCommand 中的 dontinline 指令或 exclude 指令（表示不编译）指定的方法，以及由 @DontInline 注解的方法（仅限于 JDK 内部方法），则始终不会被内联。

其次，如果调用字节码对应的符号引用未被解析、目标方法所在的类未被初始化，或者目标方法是 native 方法，都将导致方法调用无法内联。

再次，C2 不支持内联超过 9 层的调用（可以通过虚拟机参数 -XX:MaxInlineLevel 调整），以及 1 层的直接递归调用（可以通过虚拟机参数 -XX:MaxRecursiveInlineLevel 调整）。

-XX:+PrintInlining 来打印编译过程中的内联情况
```

#######code cache

```
编译生成的机器码会被部署到 Code Cache 之中。这个 Code Cache 是有大小限制的（由 Java 虚拟机参数 -XX:ReservedCodeCacheSize 控制）。
```

#######java诊断工具

```
jps将打印所有正在运行的 Java 进程。
jstat允许用户查看目标 Java 进程的类加载、即时编译以及垃圾回收相关的信息。它常用于检测垃圾回收问题以及内存泄漏问题。
jmap允许用户统计目标 Java 进程的堆中存放的 Java 对象，并将它们导出成二进制文件。
jinfo将打印目标 Java 进程的配置参数，并能够改动其中 manageabe 的参数。
jstack将打印目标 Java 进程中各个线程的栈轨迹、线程状态、锁状况等信息。它还将自动检测死锁。
jcmd则是一把瑞士军刀，可以用来实现前面除了jstat之外所有命令的功能。
```

```
Java Mission Control 是 Java 虚拟机平台上的性能监控工具。Java Flight Recorder 是 JMC 的其中一个组件，能够以极低的性能开销收集 Java 虚拟机的性能数据。
```

#######JNI

```
在 Java 代码中调用 C/C++ 代码（下面简述为 C 代码），并在其中实现所需功能。这种跨语言的调用，便需要借助 Java 虚拟机的 Java Native Interface（JNI）机制。
```



#######jvm 诊断实战

```

```



#######invokedynamic

```
功能：用以支持动态语言的方法调用
invokedynamic 底层机制的基石：方法句柄。
```



````

#######CMS

#######G1

````
面向整个内存，它没有新生代和老年代的概念，将堆划分为一块块独立的 Region （瑞警）。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。

Remembered Set 每个Region 都有一个记录引用的set
 G1工作的过程
     初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
    并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。
    最终标记：Stop The World，使用多条标记线程并发执行。
    筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。

优缺点

卡表技术

```
将堆分为512k的卡，每个卡维护一个卡表，用来表示是否有指向新生代的引用，如果有就记录为脏表，可以作为gc root 
HotSpot 引入了一个新的参数 -XX:+UseCondCardMark，来尽量减少写卡表的操作
```
````



#######ZGC

#######比较

#####4 jvm参数

#######常见的jvm配置参数

```
Java 8 为例
**日志**
**1、** -XX:+PrintFlagsFinal，打印JVM所有参数的值
**2、** -XX:+PrintGC，打印GC信息
**3、** -XX:+PrintGCDetails，打印GC详细信息
**4、** -XX:+PrintGCTimeStamps，打印GC的时间戳
**5、** -Xloggc:filename，设置GC log文件的位置
**6、** -XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息
**内存设置**
**1、** -Xms，设置堆的初始化内存大小
**2、** -Xmx，设置堆的最大内存
**3、** -Xmn，设置新生代内存大小
**4、** -Xss，设置线程栈大小
**5、** -XX:NewRatio，新生代与老年代比值
**6、** -XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1
**7、** -XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15
**8、** -XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC
**9、** -XX:MaxMetaspaceSize，元空间最大值
**10、** -XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存
**11、** -XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可
**设置垃圾收集相关**
**1、** -XX:+UseSerialGC，设置串行收集器
**2、** -XX:+UseParallelGC，设置并行收集器
**3、** -XX:+UseConcMarkSweepGC，使用CMS收集器
**4、** -XX:ParallelGCThreads，设置Parallel GC的线程数
**5、** -XX:MaxGCPauseMillis，GC最大暂停时间 ms
**6、** -XX:+UseG1GC，使用G1垃圾收集器
**CMS 垃圾回收器相关**
**1、** -XX:+UseCMSInitiatingOccupancyOnly
**2、** -XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机
**3、** -XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数
**4、** -XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上
**5、** -XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时
**G1 垃圾回收器相关**
**1、** -XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成
**2、** -XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认
**3、** -XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动
**4、** -XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改

逃逸分析配置
```



#####5常见问题

#######23、说说ZGC垃圾收集器的工作原理
#######24、垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
#####25、说说类加载的过程
#####26、Serial 垃圾收集器（单线程、 复制算法）
#####27、如何写一段简单的死锁代码？
#####28、如何找到死锁的线程？
#####29、直接内存是什么？
#####30、新生代与复制算法

#####[1、类加载的过程是什么？

#####[2、谈谈 JVM 中的常量池]

#####[3、JVM 内存区域]

#####[4、G1 收集器]
#####[5、堆的作用是什么？] 
#####[6、如何查看 JVM 当前使用的是什么垃圾收集器？]
#####[7、GC的回收流程是怎样的？  
#####[8、类的实例化顺序]
#####[9、工作中常用的 JVM 配置参数有哪些？

#####[10、Java里有哪些引用类型？

#####11、本地方法区(线程私有)

#####12、什么是本地方法栈

#####13、栈溢出的原因？

#####14、Java的内存模型是什么？（JMM是什么？）

#####15、方法区溢出的原因？

#####16、JVM 监控与分析工具你用过哪些？介绍一下。

#####17、说说类加载的过程

#####18、MinorGC、MajorGC、FullGC 什么时候发生？

#####19、谈谈你知道的垃圾收集器

#####20、复制算法（copying）

#####21、垃圾收集算法

#####22、JVM的永久代中会发生垃圾回收么

#####23、类加载器双亲委派模型机制？

#####24、为什么需要双亲委派模式？

#####25、讲讲什么情况下会出现内存溢出，内存泄漏？

#####26、JVM 如何确定垃圾对象？

#####27、OSGI（ 动态模型系统）

#####28、你平时工作中用过的JVM常用基本配置参数有哪些？

#####29、invokedynamic指令是干什么的？

#####30、程序计数器

#####31、强引用、软引用、弱引用、虚引用是什么？


#####[1、GC Roots 有哪些？

#####[2、说说Java 垃圾回收机制](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题大汇总，附答案.md#2说说java-垃圾回收机制)  


在 Java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。


#####[3、介绍一下类文件结构吧！

#####[4、分代收集算法]

#####[6、Tomcat是怎么打破双亲委派机制的呢？ 

#####[7、你知道哪些垃圾收集器？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题大汇总，附答案.md#7你知道哪些垃圾收集器)  


**序列号**

最基础的收集器，使用复制算法、单线程工作，只用一个处理器或一条线程完成垃圾收集，进行垃圾收集时必须暂停其他所有工作线程。

Serial 是虚拟机在客户端模式的默认新生代收集器，简单高效，对于内存受限的环境它是所有收集器中额外内存消耗最小的，对于处理器核心较少的环境，Serial 由于没有线程交互开销，可获得最高的单线程收集效率。

**新品**

Serial 的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。

ParNew 是虚拟机在服务端模式的默认新生代收集器，一个重要原因是除了 Serial 外只有它能与 CMS 配合。自从 JDK 9 开始，ParNew 加 CMS 不再是官方推荐的解决方案，官方希望它被 G1 取代。

**并行清理**

新生代收集器，基于复制算法，是可并行的多线程收集器，与 ParNew 类似。

特点是它的关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。

**串行旧**

Serial 的老年代版本，单线程工作，使用标记-整理算法。

Serial Old 是虚拟机在客户端模式的默认老年代收集器，用于服务端有两种用途：① JDK5 及之前与 Parallel Scavenge 搭配。② 作为CMS 失败预案。

**平行老**

Parallel Scavenge 的老年代版本，支持多线程，基于标记-整理算法。JDK6 提供，注重吞吐量可考虑 Parallel Scavenge 加 Parallel Old。

**不育系**

以获取最短回收停顿时间为目标，基于标记-清除算法，过程相对复杂，分为四个步骤：初始标记、并发标记、重新标记、并发清除。

初始标记和重新标记需要 STW（Stop The World，系统停顿），初始标记仅是标记 GC Roots 能直接关联的对象，速度很快。并发标记从 GC Roots 的直接关联对象开始遍历整个对象图，耗时较长但不需要停顿用户线程。重新标记则是为了修正并发标记期间因用户程序运作而导致标记产生变动的那部分记录。并发清除清理标记阶段判断的已死亡对象，不需要移动存活对象，该阶段也可与用户线程并发。

缺点：① 对处理器资源敏感，并发阶段虽然不会导致用户线程暂停，但会降低吞吐量。② 无法处理浮动垃圾，有可能出现并发失败而导致 Full GC。③ 基于标记-清除算法，产生空间碎片。

**G1**

开创了收集器面向局部收集的设计思路和基于 Region 的内存布局，主要面向服务端，最初设计目标是替换 CMS。

G1 之前的收集器，垃圾收集目标要么是整个新生代，要么是整个老年代或整个堆。而 G1 可面向堆任何部分来组成回收集进行回收，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多，回收受益最大。

跟踪各 Region 里垃圾的价值，价值即回收所获空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的 Region。这种方式保证了 G1 在有限时间内获取尽可能高的收集效率。

**G1 运作过程：**

1.
初始标记：标记 GC Roots 能直接关联到的对象，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。需要 STW 但耗时很短，在 Minor GC 时同步完成。

2.
并发标记：从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图。耗时长但可与用户线程并发，扫描完成后要重新处理 SATB 记录的在并发时有变动的对象。

3.
最终标记：对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量 SATB 记录。

4.
筛选回收：对各 Region 的回收价值排序，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。


可由用户指定期望停顿时间是 G1 的一个强大功能，但该值不能设得太低，一般设置为100~300 ms。


#####[8、JVM 选项 -XX:+UseCompressedOops 有什么作用？为什么要使用](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题大汇总，附答案.md#8jvm-选项--xx:+usecompressedoops-有什么作用为什么要使用)  


当你将你的应用从 32 位的 JVM 迁移到 64 位的 JVM 时，由于对象的指针从32 位增加到了 64 位，因此堆内存会突然增加，差不多要翻倍。这也会对 CPU缓存（容量比内存小很多）的数据产生不利的影响。因为，迁移到 64 位的 JVM主要动机在于可以指定最大堆大小，通过压缩OOP 可以节省一定的内存。通过-XX:+UseCompressedOops 选项，JVM 会使用 32 位的 OOP，而不是 64 位的 OOP。


#####[9、invokedynamic 指令是干什么的？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题大汇总，附答案.md#9invokedynamic-指令是干什么的)  


Java 7 开始，新引入的字节码指令，可以实现一些动态类型语言的功能。Java 8 的 Lambda 表达式就是通过 invokedynamic 指令实现，使用方法句柄实现。


#####[10、动态改变构造](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题大汇总，附答案.md#10动态改变构造)  


OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理， OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。

#####11、怎样通过 Java 程序来判断 JVM 是 32 位 还是 64位？

```
1 通过参数，sun.arch.data.model//
```

#####12、引用计数法



#####13、在老年代-标记整理算法

#####14、Minor GC与Full GC分别在什么时候发生？

#####15、怎么获取 Java 程序使用的内存？堆使用的百分比？

```
可以通过 java.lang.Runtime 类中与内存相关方法来获取剩余的内存，总内存及
最大堆内存。通过这些方法你也可以获取到堆使用的百分比及堆内存的剩余空间。
Runtime.freeMemory() 方法返回剩余空间的字节数，Runtime.totalMemory()
方法总内存的字节数，Runtime.maxMemory() 返回最大内存的字节数。
```

#####16、在新生代-复制算法

#####17、JIT 是什么？

```
Just-In-Time (JIT) 编译器是运行时环境的一个组件，通过在运行时将字节码编译为本机机器代码来提高 Java™ 应用程序的性能。
```

#####18、双亲委派模型是什么？



#####19、列举一些你知道的打破双亲委派机制的例子。为什么要打破？



#####20、谈谈你知道的垃圾回收算法

#####21、线上常用的 JVM 参数有哪些？

#####22、各种回收算法

#####23、JVM 有哪些运行时内存区域？

#####24、说说线程栈

#####25、JAVA8 与元数据

```
java 8 新特性
从下面2个层面 说明
语言  Lambda 函数式接口
编译器 使用新的javac编译器以及-parameters参数
库 Optional Streams 时间类 Nashorn JavaScript引擎 Base64  并行数组 concurrent
工具 Nashorn引擎：jjs    类依赖分析器：jdeps
运行时 使用Metaspace（JEP 122）代替持久代（PermGen space）。在JVM参数方面，使用-XX:MetaSpaceSize和-XX:MaxMetaspaceSize代替原来的-XX:PermSize和-XX:MaxPermSize。
```



#######java 8的元数据区 

```
java8用metaspace 替代permgen 永久代

替换的目的 :1 PermGen 经常会内存溢出，2 
对应的垃圾回收 full gc 

替代permgen字符串常量池--->迁移到head 
替代permgen的类信息迁移到metaspace区

```



G1收集器



#####26、说说你知道的几种主要的JVM参数

#####27、生产环境用的什么JDK？如何配置的垃圾收集器？

#####28、本地方法栈的作用？

#####29、JVM 中一次完整的 GC 流程（从 ygc 到 fgc）是怎样的

#####30、GC日志的real、user、sys是什么意思？

#####31、GC 是什么? 为什么要有 GC

#####[1、ZGC 了解吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#1zgc-了解吗)  


JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。

基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。

ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。


#####[2、safepoint是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#2safepoint是什么)  


STW并不会只发生在内存回收的时候。现在程序员这么卷，碰到几次safepoint的问题几率也是比较大的。

当发生GC时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为JVM是安全的（safe），整个堆的状态是稳定的。

如果在GC前，有线程迟迟进入不了safepoint，那么整个JVM都在等待这个阻塞的线程，造成了整体GC的时间变长。


#####[3、JVM 提供的常用工具](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#3jvm-提供的常用工具)  


**jps：**

用来显示本地的 Java 进程，可以查看本地运行着几个 Java 程序，并显示他们的进程号。 命令格式：jps

**jinfo：**

运行环境参数：Java System 属性和 JVM 命令行参数，Java class path 等信息。 命令格式：jinfo 进程 pid

**jstat：**

监视虚拟机各种运行状态信息的命令行工具。 命令格式：jstat -gc 123 250 20

**jstack：**

可以观察到 JVM 中当前所有线程的运行情况和线程当前状态。 命令格式：jstack 进程 pid

**jmap：**

观察运行中的 JVM 物理内存的占用情况（如：产生哪些对象，及其数量）。 命令格式：jmap [option] pid


#####[4、CMS 收集器（多线程标记清除算法）](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#4cms-收集器多线程标记清除算法)  


Concurrent mark sweep(CMS)收集器是一种年老代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间， 和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂。整个过程分为以下 4 个阶段：

**初始标记**

只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。

**并发标记**

进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。

**重新标记**

为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。

**并发清除**

清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作， 所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。


#####[5、对象都是优先分配在年轻代上的吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#5对象都是优先分配在年轻代上的吗)  


不是。当新生代内存不够时，老年代分配担保。而大对象则是直接在老年代分配。


#####[6、有哪些 GC 算法？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#6有哪些-gc-算法)  


**标记-清除算法**

分为标记和清除阶段，首先从每个 GC Roots 出发依次标记有引用关系的对象，最后清除没有标记的对象。

执行效率不稳定，如果堆包含大量对象且大部分需要回收，必须进行大量标记清除，导致效率随对象数量增长而降低。

存在内存空间碎片化问题，会产生大量不连续的内存碎片，导致以后需要分配大对象时容易触发 Full GC。

**标记-复制算法**

为了解决内存碎片问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。主要用于进行新生代。

实现简单、运行高效，解决了内存碎片问题。代价是可用内存缩小为原来的一半，浪费空间。

HotSpot 把新生代划分为一块较大的 Eden 和两块较小的 Survivor，每次分配内存只使用 Eden 和其中一块 Survivor。垃圾收集时将 Eden 和 Survivor 中仍然存活的对象一次性复制到另一块 Survivor 上，然后直接清理掉 Eden 和已用过的那块 Survivor。HotSpot 默认Eden 和 Survivor 的大小比例是 8:1，即每次新生代中可用空间为整个新生代的 90%。

**标记-整理算法**

标记-复制算法在对象存活率高时要进行较多复制操作，效率低。如果不想浪费空间，就需要有额外空间分配担保，应对被使用内存中所有对象都存活的极端情况，所以老年代一般不使用此算法。

老年代使用标记-整理算法，标记过程与标记-清除算法一样，但不直接清理可回收对象，而是让所有存活对象都向内存空间一端移动，然后清理掉边界以外的内存。

标记-清除与标记-整理的差异在于前者是一种非移动式算法而后者是移动式的。如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且移动必须全程暂停用户线程。如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和访问器解决。


#####[7、有什么堆外内存的排查思路？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#7有什么堆外内存的排查思路)  


进程占用的内存，可以使用top命令，看RES段占用的值。如果这个值大大超出我们设定的最大堆内存，则证明堆外内存占用了很大的区域。

使用gdb可以将物理内存dump下来，通常能看到里面的内容。更加复杂的分析可以使用perf工具，或者谷歌开源的gperftools。那些申请内存最多的native函数，很容易就可以找到。


#####[8、SWAP会影响性能么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#8swap会影响性能么)  


当操作系统内存不足的时候，会将部分数据写入到SWAP交换分中，但是SWAP的性能是比较低的。如果应用的访问量较大，需要频繁申请和销毁内存，就容易发生卡顿。一般高并发场景下，会禁用SWAP。


#####[9、你知道哪些JVM性能调优](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#9你知道哪些jvm性能调优)  


**设定堆内存大小**

**1、** -Xmx：堆内存最大限制。设定新生代大小。新生代不宜太小，否则会有大量对象涌入老年代

**2、** -XX:NewSize：新生代大小

**3、** -XX:NewRatio 新生代和老生代占比

**4、** -XX:SurvivorRatio：伊甸园空间和幸存者空间的占比

**5、** 设定垃圾回收器 年轻代用 -XX:+UseParNewGC 年老代用-XX:+UseConcMarkSweepGC

#####[10、你都有哪些手段用来排查内存溢出？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题附答案解析，大汇总.md#10你都有哪些手段用来排查内存溢出)  


（这个话题很大，可以从实践环节中随便摘一个进行总结，下面举例一个最普通的）

你可以来一个中规中矩的回

内存溢出包含很多种情况，我在平常工作中遇到最多的就是`堆溢出`。有一次线上遇到故障，重新启动后，使用jstat命令，发现Old区在一直增长。我使用jmap命令，导出了一份线上堆栈，然后使用`MAT`进行分析。通过对`GC Roots`的分析，我发现了一个非常大的HashMap对象，这个原本是有位同学`做缓存`用的，但是一个无界缓存，造成了堆内存占用一直上升。后来，将这个缓存改成 guava的Cache，并设置了弱引用，故障就消失了。

这个回答不是十分出彩，但着实是常见问题，让人挑不出毛病。


#####11、JIT是什么？

#####12、Java 中堆和栈有什么区别？

#####13、方法区

#####14、你能保证 GC 执行吗？

#####15、说说G1垃圾收集器的工作原理

#####16、方法区的作用是什么？

#####17、ParNew 垃圾收集器（Serial+多线程）

#####18、你知道哪些内存分配与回收策略？

#####19、什么是栈

#####20、Minor Gc和Full GC 有什么不同呢？

#####21、JVM怎么判断一个对象是不是要回收？

#####22、说一下Java对象的创建过程

#####23、怎么看死锁的线程？

#####24、JVM垃圾回收机制，何时触发MinorGC等操作

#####25、GC垃圾回收算法与垃圾收集器的关系？

#####26、永久代

#####27、谈谈JVM中，对类加载器的认识

#####28、描述一下什么情况下，对象会从年轻代进入老年代

#####29、可达性分析

#####30、描述一下JVM加载class文件的原理机制？

#####31、描述一下 JVM 加载 class 文件的原理机制



#####[1、JAVA弱引用](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#1java弱引用)  


弱引用需要用 WeakReference 类来实现，它比软引用的生存期更短，对于只有弱引用的对象来说，只要垃圾回收机制一运行，不管 JVM 的内存空间是否足够，总会回收该对象占用的内存。


#####[2、什么是堆](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#2什么是堆)  


存放对象实例，所有的对象和数组都要在堆上分配。 是 JVM 所管理的内存中最大的一块区域。


#####[3、什么是程序计数器](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#3什么是程序计数器)  


当前线程所执行的行号指示器。是 JVM 内存区域最小的一块区域。执行字节码工作时就是利用程序计数器来选取下一条需要执行的字节码指令。


#####[4、各种回收器，各自优缺点，重点CMS、G1](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#4各种回收器各自优缺点重点cmsg1)  


图来源于《深入理解Java虚拟机：JVM高级特效与最佳实现》，图中两个收集器之间有连线，说明它们可以配合使用.

**1、** Serial收集器，串行收集器是最古老，最稳定以及效率高的收集器，但可能会产生较长的停顿，只使用一个线程去回收。

**2、** ParNew收集器，ParNew收集器其实就是Serial收集器的多线程版本。

**3、** Parallel收集器，Parallel Scavenge收集器类似ParNew收集器，Parallel收集器更关注系统的吞吐量。

**4、** Parallel Old收集器，Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程“标记－整理”算法

**5、** CMS收集器，CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它需要消耗额外的CPU和内存资源，在CPU和内存资源紧张，CPU较少时，会加重系统负担。CMS无法处理浮动垃圾。CMS的“标记-清除”算法，会导致大量空间碎片的产生。

**6、** G1收集器，G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器、以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征。


#####[5、可以描述一下 class 文件的结构吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#5可以描述一下-class-文件的结构吗)  


**1、** Class 文件包含了 Java 虚拟机的指令集、符号表、辅助信息的字节码(Byte Code)，是实现跨操作系统和语言无关性的基石之一。

**2、** 一个 Class 文件定义了一个类或接口的信息，是以 8 个字节为单位，没有分隔符，按顺序紧凑排在一起的二进制流。

**3、** 用 "无符号数" 和 "表" 组成的伪结构来存储数据。

**4、** 无符号数：基本数据类型，用来描述数字、索引引用、数量值、字符串值，如u1、u2 分别表示 1 个字节、2 个字节

**10、** 表：无符号数和其他表组成，命名一般以 "_info" 结尾

**组成部分**

**1、** 魔数 Magic Number

Class 文件头 4 个字节，0xCAFEBABE

作用是确定该文件是 Class 文件

**2、** 版本号

4 个字节，前 2 个是次版本号 Minor Version，后 2 个主版本号 Major Version

从 45 (JDK1.0) 开始，如 0x00000032 转十进制就是 50，代表 JDK 6

低版本的虚拟机跑不了高版本的 Class 文件

**3、** 常量池

常量容量计数值(constant_pool_count)，u2，从 1 开始。如 0x0016 十进制 22 代表有

21 项常量

每项常量都是一个表，目前 17 种

特点：Class 文件中最大数据项目之一、第一个出现表数据结构

**4、** 访问标志

2 个字节，表示类或接口的访问标志

**5、** 类索引、父类索引、接口索引集合

类索引(this_class)、父类索引(super_class)，u2

接口索引集合(interfaces)，u2 集合

类索引确定类的全限定名、父类索引确定父类的全限定名、接口索引集合确定实现接口

索引值在常量池中查找对应的常量

**6、** 字段表(field_info)集合

描述接口或类申明的变量

fields_count，u2，表示字段表数量；后面接着相应数量的字段表

9 种字段访问标志

**7、** 方法表(method_info)集合

**描述接口或类申明的方法**

methods_count，u2，表示方法表数量；后面接着相应数量的方法表

12 种方法访问标志

**方法表结构与字段表结构一致**

**8、** 属性表(attribute_info)集合

class 文件、字段表、方法表可携带属性集合，描述特有信息

预定义 29 项属性，可自定义写入不重名属性


#####[6、类的实例化顺序](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#6类的实例化顺序)  


**比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序**

先静态、先父后子。

先静态：父静态 > 子静态

优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数

**一个类的实例化过程：**

**1、** 父类中的static代码块，当前类的static

**2、** 顺序执行父类的普通代码块

**3、** 父类的构造函数

**4、** 子类普通代码块

**5、** 子类（当前类）的构造函数，按顺序执行。

**6、** 子类方法的执行，


#####[7、怎么打出线程栈信息？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#7怎么打出线程栈信息)  


输入jps，获得进程号。top -Hp pid 获取本进程中所有线程的CPU耗时性能 jstack pid命令查看当前java进程的堆栈状态 或者 jstack -l > /tmp/output.txt 把堆栈信息打到一个txt文件。可以使用fastthread 堆栈定位（fastthread.io）


#####[8、程序计数器是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#8程序计数器是什么)  


**程序计数器**是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。

如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。


#####[9、JVM的引用类型有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#9jvm的引用类型有哪些)  


引用内型：

**强引用：**

当内存不足的时候，JVM宁可出现OutOfMemoryError错误停止，也需要进行保存，并且不会将此空间回收。在引用期间和栈有联系就无法被回收

**软引用：**

当内存不足的时候，进行对象的回收处理，往往用于高速缓存中；mybatis就是其中

**弱引用：**

不管内存是否紧张，只要有垃圾了就立即回收

**幽灵引用：**

和没有引用是一样的


#####[10、Serial 与 Parallel GC 之间的不同之处？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新2021年面试题及答案，汇总版.md#10serial-与-parallel-gc-之间的不同之处)  


Serial 与 Parallel 在 GC 执行的时候都会引起 stop-the-world。它们之间主要不同 serial 收集器是默认的复制收集器，执行 GC 的时候只有一个线程，而parallel 收集器使用多个 GC 线程来执行。


#####11、JVM新生代中为什么要分为Eden和Survivor？

#####12、老年代

#####13、常用JVM基本配置参数

#####14、如何判断一个类是无用的类?

#####15、什么是 Class 文件？ Class 文件主要的信息结构有哪些？

#####16、Java 堆的结构是什么样子的？什么是堆中的永久代（Perm Gen space）

#####17、如何判断对象可以被回收

#####18、JVM有哪些内存区域？(JVM的内存布局是什么？)

#####19、说说CMS垃圾收集器的工作原理

#####20、类加载是什么？

#####21、JAVA虚引用

#####22、对于JDK自带的监控和性能分析工具用过哪些？

#####23、什么是指令重排序？

#####24、有哪些类加载器？

#####25、堆和栈的区别

#####26、Java会存在内存泄漏吗？请简单描述。

#####27、生产环境服务器变慢，如何诊断处理？

#####28、什么是逃逸分析？

#####29、java中会存在内存泄漏吗，请简单描述。

#####30、程序计数器为什么是私有的?





#####[1、谈谈动态年龄判断](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#1谈谈动态年龄判断)  


**1、** 这里涉及到 -XX:TargetSurvivorRatio 参数，Survivor 区的目标使用率默认 50，即 Survivor 区对象目标使用率为 50%。

**2、** Survivor 区相同年龄所有对象大小的总和 (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。

**3、** 当然，这里还需要考虑参数 -XX:MaxTenuringThreshold 晋升年龄最大阈值


#####[2、类初始化的情况有哪些？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#2类初始化的情况有哪些)  


1.
遇到 `new`、`getstatic`、`putstatic` 或 `invokestatic` 字节码指令时，还未初始化。典型场景包括 new 实例化对象、读取或设置静态字段、调用静态方法。

2.
对类反射调用时，还未初始化。

3.
初始化类时，父类还未初始化。

4.
虚拟机启动时，会先初始化包含 main 方法的主类。

5.
使用 JDK7 的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且句柄对应的类还未初始化。

6.
口定义了默认方法，如果接口的实现类初始化，接口要在其之前初始化。

7.
其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用实例：① 子类使用父类的静态字段时，只有父类被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。

8.
接口和类加载过程的区别：初始化类时如果父类没有初始化需要初始化父类，但接口初始化时不要求父接口初始化，只有在真正使用父接口时（如引用接口中定义的常量）才会初始化。



#####[3、GC 是什么？为什么要有 GC？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#3gc-是什么为什么要有-gc)  


GC 是垃 圾收 集的 意思 ，内存 处理 是编 程人 员容 易出 现问 题的 地方 ，忘记 或者 错误的内 存回 收会 导致 程序 或系 统的 不稳 定甚 至崩 溃， Java 提供 的 GC 功能 可以 自动监测 对象 是否 超过 作用 域从 而达 到自 动回 收内 存的 目的 ，Java 语言 没有 提供 释放已分配内存的 显示 操作 方法 。Java 程序 员不 用担 心内 存管 理， 因为 垃圾 收集 器会自动 进行 管理 。要 请求 垃圾 收集 ，可 以调 用下 面的 方法 之一 ：System.gc() 或Runtime.getRuntime().gc() ，但 JVM 可以 屏蔽 掉线 示的 垃圾 回收 调用 。

垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低优先级的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清除和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。在 Java 诞生初期，垃圾回收是 Java最大的亮点之一，因为服务器端的编程需要有效的防止内存泄露问题，然而时过境迁，如今 Java 的垃圾回收机制已经成为被诟病的东。移动智能终端用户通常觉得 iOS 的系统比 Android 系统有更好的用户体验，其中一个深层次的原因就在于 Android 系统中垃圾回收的不可预知性。


#####[4、MinorGC，MajorGC、FullGC都什么时候发生？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#4minorgcmajorgcfullgc都什么时候发生)  


MinorGC在年轻代空间不足的时候发生，MajorGC指的是老年代的GC，出现MajorGC一般经常伴有MinorGC。

FullGC有三种情况。

**1、** 当老年代无法再分配内存的时候

**2、** 元空间不足的时候

**3、** 显示调用System.gc的时候。另外，像CMS一类的垃圾回收器，在MinorGC出现promotion failure的时候也会发生FullGC


#####[5、Java的双亲委托机制是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#5java的双亲委托机制是什么)  


它的意思是，除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。

Java默认是这种行为。当然Java中也有很多打破双亲行为的骚操作，比如SPI（JDBC驱动加载），OSGI等。


#####[6、在 Java 中，对象什么时候可以被垃圾回收？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#6在-java-中对象什么时候可以被垃圾回收)  


当对象对当前使用这个对象的应用程序变得不可触及的时候，这个对象就可以被回收了。


#####[7、有哪些打破了双亲委托机制的案例？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#7有哪些打破了双亲委托机制的案例)  


**1、** Tomcat可以加载自己目录下的class文件，并不会传递给父类的加载器。

**2、** Java的SPI，发起者是 `BootstrapClassLoader`， `BootstrapClassLoader`已经是最上层的了。它直接获取了 `AppClassLoader`进行驱动加载，和双亲委派是相反的。。


#####[8、JVM 年轻代到年老代的晋升过程的判断条件是什么呢？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#8jvm-年轻代到年老代的晋升过程的判断条件是什么呢)  


**1、** 部分对象会在From和To区域中复制来复制去,如此交换15次(由JVM参数MaxTenuringThreshold决定,这个参数默认是15),最终如果还是存活,就存入到老年代。

**2、** 如果对象的大小大于Eden的二分之一会直接分配在old，如果old也分配不下，会做一次majorGC，如果小于eden的一半但是没有足够的空间，就进行minorgc也就是新生代GC。

**3、** minor gc后，survivor仍然放不下，则放到老年代

**4、** 动态年龄判断 ，大于等于某个年龄的对象超过了survivor空间一半 ，大于等于某个年龄的对象直接进入老年代


#####[9、JVM 数据运行区，哪些会造成 OOM 的情况？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#9jvm-数据运行区哪些会造成-oom-的情况)  


除了数据运行区，其他区域均有可能造成 OOM 的情况。

**堆溢出：**java.lang.OutOfMemoryError: Java heap space

**栈溢出：**java.lang.StackOverflowError

**永久代溢出：**java.lang.OutOfMemoryError: PermGen space


#####[10、JVM 类加载机制](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题2021年，常见面试题及答案汇总.md#10jvm-类加载机制)  


JVM 类加载机制分为五个部分：加载，验证，准备，解析，初始化。

**加载**

加载是类加载过程中的一个阶段， 这个阶段会在内存中生成一个代表这个类的 java.lang.Class 对象， 作为方法区这个类的各种数据的入口。注意这里不一定非得要从一个 Class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类）。

**验证**

这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

**准备**

准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。注意这里所说的初始值概念，比如一个类变量定义为：

实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器方法之中。

**但是注意如果声明为：**

public static final int v = 8080;

在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。

**解析**

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的

public static int v = 8080;

实际上变量 v 在准备阶段过后的初始值为 0 而不是 8080， 将 v 赋值为 8080 的 put static 指令是程序被编译后， 存放于类构造器方法之中。但是注意如果声明为：

在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。

**解析**

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的

public static final int v = 8080;

在编译阶段会为 v 生成 ConstantValue 属性，在准备阶段虚拟机会根据 ConstantValue 属性将 v赋值为 8080。

**解析**

解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。符号引用就是 class 文件中的：

**1、** CONSTANT_Class_info

**2、** CONSTANT_Field_info

**3、** CONSTANT_Method_info

等类型的常量。

**符号引用**

符号引用与虚拟机实现的布局无关， 引用的目标并不一定要已经加载到内存中。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在 Java 虚拟机规范的 Class 文件格式中。

**直接引用**

直接引用可以是指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那引用的目标必定已经在内存中存在。

**初始化**

初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。

**类构造器**

初始化阶段是执行类构造器方法的过程。方法是由编译器自动收集类中的类变量的赋值操作和静态语句块中的语句合并而成的。虚拟机会保证子方法执行之前，父类的方法已经执行完毕， 如果一个类中没有对静态变量赋值也没有静态语句块，那么编译器可以不为这个类生成()方法。

**注意以下几种情况不会执行类初始化：**

**1、** 通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。

**2、** 定义对象数组，不会触发该类的初始化。

**3、** 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。

**4、** 通过类名获取 Class 对象，不会触发类的初始化。

**5、** 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。

**6、** 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。


#####11、字符串常量存放在哪个区域？

#####12、对象的访问方式有哪些？

#####13、说一下 JVM 调优的工具？

#####14、对象分配内存是否线程安全？

#####15、什么时候会造成堆外内存溢出？

#####16、你都用过G1垃圾回收器的哪几个重要参数？

#####17、双亲委派

#####18、Parallel Old 收集器（多线程标记整理算法）

#####19、Java 程序是怎样运行的？

#####20、请解释StackOverflowError和OutOfMemeryError的区别？

#####21、分区收集算法

#####22、串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？

#####23、栈帧都有哪些数据？

#####24、对象在哪块内存分配？

#####25、运行时常量池溢出的原因？

#####26、safepoint 是什么？

#####27、JVM调优命令有哪些？

#####28、你说你做过JVM参数调优和参数配置，请问如何查看JVM系统默认值

#####29、Java 中会存在内存泄漏?简述一下

#####30、对象是怎么从年轻代进入老年代的？

#####31、什么情况下会发生栈内存溢出？

#####1、堆

JVM内存管理最大的一块,对被线程共享,目的是存放对象的实例,几乎所欲的对象实例都会放在这里,当堆没有可用空间时,会抛出OOM异常.根据对象的存活周期不同,JVM把对象进行分代管理,由垃圾回收器进行垃圾的回收管理


#####[2、老年代与标记复制算法](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#2老年代与标记复制算法)  


**而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。**

**1、** JAVA 虚拟机提到过的处于方法区的永生代(Permanet Generation)， 它用来存储 class 类，常量，方法描述等。对永生代的回收主要包括废弃常量和无用的类。

**2、** 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space(Survivor 目前存放对象的那一块)，少数情况会直接分配到老生代。

**3、** 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC，进行 GC 后， EdenSpace 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 FromSpace 进行清理。

**4、** 如果 To Space 无法足够存储某个对象，则将这个对象存储到老生代。

**5、** 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。

**6、** 当对象在 Survivor 去躲过一次 GC 后，其年龄就会+1。默认情况下年龄到达 15 的对象会被移到老生代中。


#####[3、分代回收](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#3分代回收)  


分代回收基于两个事实:大部分对象很快就不使用了,还有一部分不会立即无用,但也不会持续很长时间

年轻代->标记-复制

老年代->标记-清除


#####[4、说一下堆和栈的区别](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#4说一下堆和栈的区别)  


**1、** 物理地址 堆的物理地址分配对对象是不连续的。因此性能慢些。在GC的时候也要考虑到不连续的分配，所以有各种算法。比如，标记-消除，复制，标记-压缩，分代（即新生代使用复制算法，老年代使用标记——压缩） 栈使用的是数据结构中的栈，先进后出的原则，物理地址分配是连续的。所以性能快。

**2、** 内存分别 堆因为是不连续的，所以分配的内存是在运行期确认的，因此大小不固定。一般堆大小远远大于栈。栈是连续的，所以分配的内存大小要在编译期就确认，大小是固定的。

**3、** 存放的内容 堆存放的是对象的实例和数组。因此该区更关注的是数据的存储 栈存放：局部变量，操作数栈，返回结果。该区更关注的是程序方法的执行。

**4、** 程序的可见度 堆对于整个应用程序都是共享、可见的。栈只对于线程是可见的。所以也是线程私有。他的生命周期和线程相同。


#####[5、方法区/永久代（线程共享）](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#5方法区/永久代线程共享)  


即我们常说的永久代(Permanent Generation), 用于存储被 JVM 加载的类信息、常量、静态变量即、时编译器编译后的代码等数据.HotSpot VM把GC分代收集扩展至方法区, 即使用Java堆的永久代来实现方法区, 这样 HotSpot 的垃圾收集器就可以像管理 Java 堆一样管理这部分内存,而不必为方法区开发专门的内存管理器(永久带的内存回收的主要目标是针对常量池的回收和类型的卸载, 因此收益一般很小) 。

运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池 （Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。Java 虚拟机对 Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。


#####[6、类加载器](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#6类加载器)  


虚拟机设计团队把加载动作放到 JVM 外部实现，以便让应用程序决定如何获取所需的类， JVM 提供了 3 种类加载器：

启动类加载器(Bootstrap ClassLoader)

负责加载 JAVA_HOME\lib 目录中的， 或通过-Xbootclasspath 参数指定路径中的， 且被虚拟机认可（按文件名识别， 如 rt.jar） 的类。

**扩展类加载器(Extension ClassLoader)**

负责加载 JAVA_HOME\lib\ext 目录中的，或通过 java.ext.dirs 系统变量指定路径中的类库。

**应用程序类加载器(Application ClassLoader)：**

负责加载用户路径（classpath）上的类库。JVM 通过双亲委派模型进行类的加载， 当然我们也可以通过继承 java.lang.ClassLoader实现自定义的类加载器。


#####[7、谈谈永久代](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#7谈谈永久代)  


**1、** JDK 8 之前，Hotspot 中方法区的实现是永久代（Perm）

**2、** JDK 7 开始把原本放在永久代的字符串常量池、静态变量等移出到堆，JDK 8 开始去除永久代，使用元空间（Metaspace），永久代剩余内容移至元空间，元空间直接在本地内存分配。


#####[8、ZGC收集器中的染色指针有什么用？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#8zgc收集器中的染色指针有什么用)  


染色指针是一种直接将少量额外的信息存储在指针上的技术，可是为什么指针本身也可以存储额外信息呢？在64位系统中，理论可以访问的内存高达16EB（2的64次幂）字节 [3] 。实际上，基于需求（用不到那么多内存）、性能（地址越宽在做地址转换时需要的页表级数越多）和成本（消耗更多晶体管）的考虑，在AMD64架构 [4] 中只支持到52位（4PB）的地址总线和48位（256TB）的虚拟地址空间，所以目前64位的硬件实际能够支持的最大内存只有256TB。此外，操作系统一侧也还会施加自己的约束，64位的Linux则分别支持47位（128TB）的进程虚拟地址空间和46位（64TB）的物理地址空间，64位的Windows系统甚至只支持44位（16TB）的物理地址空间。尽管Linux下64位指针的高18位不能用来寻址，但剩余的46位指针所能支持的64TB内存在今天仍然能够充分满足大型服务器的需要。鉴于此，ZGC的染色指针技术继续盯上了这剩下的46位指针宽度，将其高4位提取出来存储四个标志信息。通过这些标志位，虚拟机可以直接从指针中看到其引用对象的三色标记状态、是否进入了重分配集（即被移动过）、是否只能通过finalize()方法才能被访问到。当然，由于这些标志位进一步压缩了原本就只有46位的地址空间，也直接导致ZGC能够管理的内存不可以超过4TB（2的42次幂） 。


#####[9、JVM垃圾回收时候如何确定垃圾？什么是GC Roots？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#9jvm垃圾回收时候如何确定垃圾什么是gc-roots)  


JVM采用的是可达性分析算法。JVM是通过GC Roots来判定对象的存活的。从`GC Roots`向下追溯、搜索，会产生一个叫做`Reference Chain`的链条。当一个对象不能和任何一个GC Root产生关系，就判定为垃圾。

**GC Roots大体包括：**

**1、** 活动线程相关的各种引用，比如虚拟机栈中栈帧里的引用。

**2、** 类的静态变量的引用。

**3、** JNI引用等。

**当然也有比较详细的回答，个人认为这些就够了。详细版本如下：**

**1、** Java线程中，当前所有正在被调用的方法的 `引用类型`参数、局部变量、临时值等。也就是与我们 `栈帧`相关的各种引用。

**2、** 所有当前被加载的Java类。

**3、** Java类的引用类型静态变量。

**4、** 运行时常量池里的引用类型常量（String或Class类型）。

**5、** JVM内部数据结构的一些引用，比如 `sun.jvm.hotspot.memory.Universe`类。

**6、** 用于同步的监控对象，比如调用了对象的 `wait()`方法。

**7、** JNI handles，包括global handles和local handles


#####[10、什么是内存屏障？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，2021年面试题及答案汇总.md#10什么是内存屏障)  


内存屏障，也叫内存栅栏，是一种CPU指令，用于控制特定条件下的重排序和内存可见性问题。LoadLoad屏障：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。StoreStore屏障：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，保证Store1的写入操作对其它处理器可见。LoadStore屏障：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。StoreLoad屏障：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能。


#####11、栈

#####12、stackoverflow错误，permgen space错误

#####13、虚拟机栈(线程私有)

#####14、分代收集算法

#####15、你知道哪些故障处理工具？

#####16、假如生产环境CPU占用过高，请谈谈你的分析思路和定位。

#####17、32 位和 64 位的 JVM，int 类型变量的长度是多数？

#####18、什么是方法内联？

#####19、什么是类加载器，类加载器有哪些？

#####20、模块化编程与热插拔

#####21、什么时候会触发FullGC

#####22、程序计数器有什么作用？

#####23、运行时数据区是什么？

#####24、标记清除算法（ Mark-Sweep）

#####25、运行时常量池的作用是什么?

#####26、栈帧里面包含哪些东西？

#####27、对象分配内存的方式有哪些？

#####28、什么是方法区

#####29、Java 内存分配

#####30、堆（Heap-线程共享） -运行时数据区





#####[1、类加载有几个过程？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#1类加载有几个过程)  


加载、验证、准备、解析、初始化。


#####[2、简述Java的对象结构](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#2简述java的对象结构)  


Java对象由三个部分组成：对象头、实例数据、对齐填充。

对象头由两部分组成，第一部分存储对象自身的运行时数据：哈希码、GC分代年龄、锁标识状态、线程持有的锁、偏向线程ID（一般占32/64 bit）。第二部分是指针类型，指向对象的类元数据类型（即对象代表哪个类）。如果是数组对象，则对象头中还有一部分用来记录数组长度。

实例数据用来存储对象真正的有效信息（包括父类继承下来的和自己定义的）

对齐填充：JVM要求对象起始地址必须是8字节的整数倍（8字节对齐 )


#####[3、怎么查看服务器默认的垃圾回收器是哪一个？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#3怎么查看服务器默认的垃圾回收器是哪一个)  


这通常会使用另外一个参数：`-XX:+PrintCommandLineFlags`可以打印所有的参数，包括使用的垃圾回收器。


#####[4、JAVA 强引用](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#4java-强引用)  


在 Java 中最常见的就是强引用， 把一个对象赋给一个引用变量，这个引用变量就是一个强引用。当一个对象被强引用变量引用时，它处于可达状态，它是不可能被垃圾回收机制回收的，即使该对象以后永远都不会被用到 JVM 也不会回收。因此强引用是造成 Java 内存泄漏的主要原因之一。


#####[5、详细介绍一下JVM内存模型](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#5详细介绍一下jvm内存模型)  


根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。

具体可能会聊聊jdk1.7以前的PermGen（永久代），替换成Metaspace（元空间）

**1、** 原本永久代存储的数据：符号引用(Symbols)转移到了native heap；字面量(interned strings)转移到了java heap；类的静态变量(class statics)转移到了java heap

**2、** Metaspace（元空间）存储的是类的元数据信息（metadata）

**3、** 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。

**4、** 替换的好处：一、字符串存在永久代中，容易出现性能问题和内存溢出。二、永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。


#####[6、32 位 JVM 和 64 位 JVM 的最大堆内存分别是多数？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#632-位-jvm-和-64-位-jvm-的最大堆内存分别是多数)  


理论上说上 32 位的 JVM 堆内存可以到达 2^32，即 4GB，但实际上会比这个小很多。不同操作系统之间不同，如 Windows 系统大约 1.5GB，Solaris 大约3GB。64 位 JVM 允许指定最大的堆内存，理论上可以达到 2^64，这是一个非常大的数字，实际上你可以指定堆内存大小到 100GB。甚至有的 JVM，如 Azul，堆内存到 1000G 都是可能的。


#####[7、HashMap中的key，可以是普通对象么？需要什么注意的地方？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#7hashmap中的key可以是普通对象么需要什么注意的地方)  


Map的key和value都可以是任何类型。但要注意的是，一定要重写它的equals和hashCode方法，否则容易发生内存泄漏。


#####[8、你熟悉哪些垃圾收集算法？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#8你熟悉哪些垃圾收集算法)  


标记清除（缺点是碎片化） 复制算法（缺点是浪费空间） 标记整理算法（效率比前两者差） 分代收集算法（老年代一般使用“标记-清除”、“标记-整理”算法，年轻代一般用复制算法）


#####[9、GC 垃圾收集器](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#9gc-垃圾收集器)  


Java 堆内存被划分为新生代和年老代两部分，新生代主要使用复制和标记-清除垃圾回收算法；年老代主要使用标记-整理垃圾回收算法，因此 java 虚拟中针对新生代和年老代分别提供了多种不同的垃圾收集器， JDK1.6 中 Sun HotSpot 虚拟机的垃圾收集器


#####[10、什么情况发生栈溢出？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题，常见面试题及答案汇总.md#10什么情况发生栈溢出)  


-Xss可以设置线程栈的大小，当线程方法递归调用层次太深或者栈帧中的局部变量过多时，会出现栈溢出错误 java.lang.StackOverflowError


#####11、JAVA软引用

#####12、JVM内存模型

#####13、如何判断对象是否是垃圾？

#####14、程序计数器(线程私有)

#####15、Java 中垃圾收集的方法有哪些

#####16、Java对象创建过程

#####17、简单描述一下（分代）垃圾回收的过程

#####18、被引用的对象就一定能存活吗？

#####19、Serial Old 收集器（单线程标记整理算法 ）

#####20、本地方法栈

#####21、什么是方法内联？

#####22、双亲委派机制可以被违背吗？请举例说明。

#####23、标记整理算法(Mark-Compact)

#####24、哪些是 GC Roots？

#####25、说一下堆内存中对象的分配的基本策略

#####26、JRE、JDK、JVM 及 JIT 之间有什么不同？

#####27、Java 内存分配与回收策率以及 Minor GC 和 Major GC

#####28、如何判断两个类是否相等？

#####29、Java 虚拟机栈的作用？

#####30、能够找到 Reference Chain 的对象，就一定会存活么？



#####[1、如何开启和查看 GC 日志？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#1如何开启和查看-gc-日志)  


**常见的 GC 日志开启参数包括：**

**1、** -Xloggc:filename，指定日志文件路径

**2、** -XX:+PrintGC，打印 GC 基本信息

**3、** -XX:+PrintGCDetails，打印 GC 详细信息

**4、** -XX:+PrintGCTimeStamps，打印 GC 时间戳

**5、** -XX:+PrintGCDateStamps，打印 GC 日期与时间

**6、** -XX:+PrintHeapAtGC，打印 GC 前后的堆、方法区、元空间可用容量变化

**7、** -XX:+PrintTenuringDistribution，打印熬过收集后剩余对象的年龄分布信息，有助于 MaxTenuringThreshold 参数调优设置

**8、** -XX:+PrintAdaptiveSizePolicy，打印收集器自动设置堆空间各分代区域大小、收集目标等自动调节的相关信息

**9、** -XX:+PrintGCApplicationConcurrentTime，打印 GC 过程中用户线程并发时间

**10、** -XX:+PrintGCApplicationStoppedTime，打印 GC 过程中用户线程停顿时间

**11、** -XX:+HeapDumpOnOutOfMemoryError，堆 oom 时自动 dump

**12、** -XX:HeapDumpPath，堆 oom 时 dump 文件路径

Java 9 JVM 日志模块进行了重构，参数格式发生变化，这个需要知道。

GC 日志输出的格式，会随着上面的参数不同而发生变化。关注各个分代的内存使用情况、垃圾回收次数、垃圾回收的原因、垃圾回收占用的时间、吞吐量、用户线程停顿时间。

借助工具可视化工具可以更方便的分析，在线工具 GCeasy；离线版可以使用 GCViewer。

如果现场环境不允许，可以使用 JDK 自带的 jstat 工具监控观察 GC 情况。


#####[2、Parallel Scavenge 收集器（多线程复制算法、高效）](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#2parallel-scavenge-收集器多线程复制算法高效)  


Parallel Scavenge 收集器也是一个新生代垃圾收集器，同样使用复制算法，也是一个多线程的垃圾收集器， 它重点关注的是程序达到一个可控制的吞吐量（Thoughput， CPU 用于运行用户代码的时间/CPU 总消耗时间，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)），高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。自适应调节策略也是 ParallelScavenge 收集器与 ParNew 收集器的一个重要区别。


#####[3、说下有哪些类加载器？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#3说下有哪些类加载器)  


Bootstrap ClassLoader（启动类加载器） Extention ClassLoader（扩展类加载器） App ClassLoader（应用类加载器）


#####[4、你做过 JVM 调优，说说如何查看 JVM 参数默认值？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#4你做过-jvm-调优说说如何查看-jvm-参数默认值)  


**1、** jps -v 可以查看 jvm 进程显示指定的参数

**2、** 使用 -XX:+PrintFlagsFinal 可以看到 JVM 所有参数的值

**3、** jinfo 可以实时查看和调整虚拟机各项参数


#####[5、什么是双亲委派机制？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#5什么是双亲委派机制)  


双亲委派机制的意思是除了顶层的启动类加载器以外，其余的类加载器，在加载之前，都会委派给它的父加载器进行加载。这样一层层向上传递，直到祖先们都无法胜任，它才会真正的加载。


#####[6、内存溢出和内存泄漏的区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#6内存溢出和内存泄漏的区别)  


内存溢出 OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。

内存泄露 Memory Leak，指程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终将导致内存溢出。


#####[7、强引用、软引用、弱引用、虚引用是什么，有什么区别？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#7强引用软引用弱引用虚引用是什么有什么区别)  


**1、** 强引用，就是普通的对象引用关系，如 String s = new String("ConstXiong")

**2、** 软引用，用于维护一些可有可无的对象。只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。SoftReference 实现

**3、** 弱引用，相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。WeakReference 实现

**4、** 虚引用是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来跟踪对象被垃圾回收的活动。PhantomReference 实现


#####[8、垃圾回收的优点和原理。说说2种回收机制](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#8垃圾回收的优点和原理。说说2种回收机制)  


Java 语言中一个显著的特点就是引入了垃圾回收机制，使 C++ 程序员最头疼的内存管理的问题迎刃而解，它使得 Java 程序员在编写程序的时候不再需要考虑内存管理。由于有个垃圾回收机制，Java 中的对象不再有“作用域”的概念，只有对象的引用才有"作用域"。垃圾回收可以有效的防止内存泄露，有效的使用可以使用的内存。垃圾回收器通常是作为一个单独的低级别的线程运行，不可预知的情况下对内存堆中已经死亡的或者长时间没有使用的对象进行清楚和回收，程序员不能实时的调用垃圾回收器对某个对象或所有对象进行垃圾回收。

**回收机制有分代复制垃圾回收和标记垃圾回收，增量垃圾回收。**


#####[9、说一下垃圾分代收集的过程](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#9说一下垃圾分代收集的过程)  


分为新生代和老年代，新生代默认占总空间的 1/3，老年代默认占 2/3。

新生代使用复制算法，有 3 个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1。

当新生代中的 Eden 区内存不足时，就会触发 Minor GC，过程如下：

**1、** 在 Eden 区执行了第一次 GC 之后，存活的对象会被移动到其中一个 Survivor 分区；

**2、** Eden 区再次 GC，这时会采用复制算法，将 Eden 和 from 区一起清理，存活的对象会被复制到 to 区；

**3、** 移动一次，对象年龄加 1，对象年龄大于一定阀值会直接移动到老年代

**4、** Survivor 区相同年龄所有对象大小的总和 (Survivor 区内存大小 * 这个目标使用率)时，大于或等于该年龄的对象直接进入老年代。其中这个使用率通过 -XX:TargetSurvivorRatio 指定，默认为 50%

**5、** Survivor 区内存不足会发生担保分配

**6、** 超过指定大小的对象可以直接进入老年代

Major GC，指的是老年代的垃圾清理，但并未找到明确说明何时在进行Major GC

FullGC，整个堆的垃圾收集，触发条件：

**1、** 每次晋升到老年代的对象平均大小>老年代剩余空间

**2、** MinorGC后存活的对象超过了老年代剩余空间

**3、** 元空间不足

**4、** System.gc() 可能会引起

**5、** CMS GC异常，promotion failed:MinorGC时，survivor空间放不下，对象只能放入老年代，而老年代也放不下造成；concurrent mode failure:GC时，同时有对象要放入老年代，而老年代空间不足造成

**6、** 堆内存分配很大的对象


#####[10、JVM 运行时内存](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案附答案汇总.md#10jvm-运行时内存)  


Java 堆从 GC 的角度还可以细分为: 新生代(Eden 区、 From Survivor 区和 To Survivor 区)和老年代。

**新生代**

是用来存放新生的对象。一般占据堆的 1/3 空间。由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。新生代又分为 Eden区、 ServivorFrom、 ServivorTo 三个区。

**Eden 区**

Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。

**ServivorFrom**

上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

**ServivorTo**

保留了一次 MinorGC 过程中的幸存者。

**MinorGC 的过程（复制->清空->互换）**

MinorGC 采用复制算法。

**eden、 servicorFrom 复制到 ServicorTo，年龄+1**

首先，把 Eden 和 ServivorFrom 区域中存活的对象复制到 ServicorTo 区域（如果有对象的年龄以及达到了老年的标准，则赋值到老年代区），同时把这些对象的年龄+1（如果 ServicorTo 不够位置了就放到老年区）；

**清空 eden、 servicorFrom**

然后，清空 Eden 和 ServicorFrom 中的对象；

**ServicorTo 和 ServicorFrom 互换**

最后， ServicorTo 和 ServicorFrom 互换，原 ServicorTo 成为下一次 GC 时的 ServicorFrom区。


#####11、说说 JVM 如何执行 class 中的字节码。

#####12、运行时栈帧包含哪些结构？

#####13、调优工具

#####14、你了解过哪些垃圾收集器？

#####15、JVM 出现 fullGC 很频繁，怎么去线上排查问题

#####16、你有哪些手段来排查 OOM 的问题？

#####17、32、volatile关键字的原理是什么？干什么用的？

#####18、创建对象的过程是什么？

#####19、怎么打破双亲委派模型？

#####20、JVM 的内存模型以及分区情况和作用

#####21、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言”？

#####22、什么是happen-before原则？

#####23、什么情况会造成元空间溢出？

#####24、谈谈对 OOM 的认识

#####25、请你谈谈对OOM的认识

#####26、生产上如何配置垃圾收集器的？

#####27、Java 的引用有哪些类型？

#####28、什么情况下会发生栈溢出？

#####29、对象分配规则

#####30、如何判断一个对象是否存活

#####[1、类加载为什么要使用双亲委派模式，有没有什么场景是打破了这个模式？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#1类加载为什么要使用双亲委派模式有没有什么场景是打破了这个模式)  


**双亲委托模型的重要用途是为了解决类载入过程中的安全性问题。**

**1、** 假设有一个开发者自己编写了一个名为`java.lang.Object`的类，想借此欺骗JVM。现在他要使用自定义`ClassLoader`来加载自己编写的`java.lang.Object`类。

**2、** 然而幸运的是，双亲委托模型不会让他成功。因为JVM会优先在`Bootstrap ClassLoader`的路径下找到`java.lang.Object`类，并载入它

Java的类加载是否一定遵循双亲委托模型？

**1、** 在实际开发中，我们可以通过自定义ClassLoader，并重写父类的loadClass方法，来打破这一机制。

**2、** SPI就是打破了双亲委托机制的(SPI：服务提供发现)。


#####[2、生产环境 CPU 占用过高，你如何解决？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#2生产环境-cpu-占用过高你如何解决)  


**1、** top + H 指令找出占用 CPU 最高的进程的 pid

**2、** top -H -p

在该进程中找到，哪些线程占用的 CPU 最高的线程，记录下 tid

**3、** jstack -l

threads.txt，导出进程的线程栈信息到文本，导出出现异常的话，加上 -F 参数

**4、** 将 tid 转换为十六进制，在 threads.txt 中搜索，查到对应的线程代码执行栈，在代码中查找占 CPU 比较高的原因。其中 tid 转十六进制，可以借助 Linux 的 printf "%x" tid 指令

我用上述方法查到过，jvm 多条线程疯狂 full gc 导致的CPU 100% 的问题和 JDK1.6 HashMap 并发 put 导致线程 CPU 100% 的问题


#####[3、JVM 的内存模型是什么？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#3jvm-的内存模型是什么)  


JVM 试图定义一种统一的内存模型，能将各种底层硬件以及操作系统的内存访问差异进行封装，使 Java 程序在不同硬件以及操作系统上都能达到相同的并发效果。它分为工作内存和主内存，线程无法对主存储器直接进行操作，如果一个线程要和另外一个线程通信，那么只能通过主存进行交换。


#####[4、你知道哪些GC类型？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#4你知道哪些gc类型)  


Minor GC：发生在年轻代的 GC。Major GC：发生在老年代的 GC。Full GC：全堆垃圾回收。比如 Metaspace 区引起年轻代和老年代的回收。


#####[5、如何判断一个常量是废弃常量 ？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#5如何判断一个常量是废弃常量-)  


运行时常量池主要回收的是废弃的常量。假如在常量池中存在字符串 "abc"，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 "abc" 就是废弃常量，如果这时发生内存回收的话而且有必要的话，"abc" 就会被系统清理出常量池。

#####[6、对象的内存布局了解吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#6对象的内存布局了解吗)  


对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。

**对象头**占 12B，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。

类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。

**实例数据**是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在源码中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。

**对齐填充**不是必然存在的，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。


#####[7、Java对象的布局了解过吗？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#7java对象的布局了解过吗)  


对象头区域此处存储的信息包括两部分：1、对象自身的运行时数据( MarkWord )，占8字节 存储 hashCode、GC 分代年龄、锁类型标记、偏向锁线程 ID 、 CAS 锁指向线程 LockRecord 的指针等， synconized 锁的机制与这个部分( markwork )密切相关，用 markword 中最低的三位代表锁的状态，其中一位是偏向锁位，另外两位是普通锁位。2、对象类型指针( Class Pointer )，占4字节 对象指向它的类元数据的指针、 JVM 就是通过它来确定是哪个 Class 的实例。

实例数据区域 此处存储的是对象真正有效的信息，比如对象中所有字段的内容

对齐填充区域 JVM 的实现 HostSpot 规定对象的起始地址必须是 8 字节的整数倍，换句话来说，现在 64 位的 OS 往外读取数据的时候一次性读取 64bit 整数倍的数据，也就是 8 个字节，所以 HotSpot 为了高效读取对象，就做了"对齐"，如果一个对象实际占的内存大小不是 8byte 的整数倍时，就"补位"到 8byte 的整数倍。所以对齐填充区域的大小不是固定的。


#####[8、谈谈双亲委派模型](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#8谈谈双亲委派模型)  


**1、** Parents Delegation Model，这里的 Parents 翻译成双亲有点不妥，类加载向上传递的过程中只有单亲；parents 更多的是多级向上的意思。

**2、** 除了顶层的启动类加载器，其他的类加载器在加载之前，都会委派给它的父加载器进行加载，一层层向上传递，直到所有父类加载器都无法加载，自己才会加载该类。

**3、** 双亲委派模型，更好地解决了各个类加载器协作时基础类的一致性问题，避免类的重复加载；防止核心API库被随意篡改。

**JDK 9 之前**

**1、** 启动类加载器（Bootstrp ClassLoader），加载 /lib/rt.jar、-Xbootclasspath

**2、** 扩展类加载器（Extension ClassLoader）sun.misc.Launcher$ExtClassLoader，加载 /lib/ext、java.ext.dirs

**3、** 应用程序类加载器（Application ClassLoader，sun.misc.Launcher$AppClassLoader），加载 CLASSPTH、-classpath、-cp、Manifest

**4、** 自定义类加载器

JDK 9 开始 Extension ClassLoader 被 Platform ClassLoader 取代，启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader

类加载代码逻辑

```
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
  // 首先，检查请求的类是否已经被加载过了
  Class c = findLoadedClass(name);
  if (c == null) {
    try {
      if (parent != null) {
        c = parent.loadClass(name, false);
      } else {
        c = findBootstrapClassOrNull(name);
      }
    } catch (ClassNotFoundException e) {
      // 如果父类加载器抛出ClassNotFoundException
      // 说明父类加载器无法完成加载请求
    }
    if (c == null) {
      // 在父类加载器无法加载时
      // 再调用本身的findClass方法来进行类加载
      c = findClass(name);
    }
  }
  if (resolve) {
    resolveClass(c);
  }
  return c;
}
```


#####[9、CMS分为哪几个阶段?](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#9cms分为哪几个阶段)  


CMS已经弃用。生活美好，时间有限，不建议再深入研究了。如果碰到问题，直接祭出回收过程即可。

**1、** 初始标记

**2、** 并发标记

**3、** 并发预清理

**4、** 并发可取消的预清理

**5、** 重新标记

**6、** 并发清理

由于《深入理解java虚拟机》一书的流行，面试时省略3、4步一般也是没问题的。


#####[10、解释 Java 堆空间及 GC？](https://gitee.com/souyunku/DevBooks/blob/master/docs/Jvm/Jvm最新面试题及答案整理，汇总版.md#10解释-java-堆空间及-gc)  


当通过 Java 命令启动 Java 进程的时候，会为它分配内存。内存的一部分用于创建堆空间，当程序中创建对象的时候，就从对空间中分配内存。GC 是 JVM 内部的一个进程，回收无效对象的内存用于将来的分配。


#####11、调优命令有哪些？

#####12、Java 中 WeakReference 与 SoftReference 的区别？

#####13、JRE、JDK、JVM 及 JIT 之间有什么不同？

#####14、CMS都有哪些问题？

#####15、Java 8 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢？

#####16、64 位 JVM 中，int 的长度是多数？

#######17、介绍一下 JVM 中垃圾收集器有哪些？ 他们特点分别是什么？

#######18、JVM中一次完整的GC流程是怎样的，对象如何晋升到老年代？

#######19、遇到过堆外内存溢出吗？

#######20、对象的访问定位有哪几种方式?

#######21、什么是分布式垃圾回收（DGC）？它是如何工作的？

#######22、遇到过元空间溢出吗？



#####6 参考资料

```
参考资料 https://github.com/doocs/jvm
极客时间java研究员总结
```
