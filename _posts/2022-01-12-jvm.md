---
layout: page
---

### 1 jvm内存结构

```
参考资料 https://github.com/doocs/jvm
```

##### java代码的运行

```
运行方式：双击jar 命令中运行 网页中 
运行环境 jre，jre包括jvm java核心类库。
运行过程：
```

##### 类的加载过程

```
1 加载，分三步，1 根据包名+类名加载文件二进制文件 2 存储在方法区 3 生成类的class实例
2 验证  文件格式 元数据 字节码 符号引用
3 准备 为静态变量分配内存并设置0值，
4 解析 
5 初始化
```

##### jvm常量池

```
JDK 1.8 开始
**1、** 字符串常量池：存放在堆中，包括 String 对象执行 intern() 方法后存的地方、双引号直接引用的字符串
**2、** 运行时常量池：存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中 constant_pool 的内容
**3、** 类文件常量池：constant_pool，JVM 定义的概念
```

##### jvm内存结构

![image-20220225110539266](../images/image-20220225110539266.png)

```
方法区
堆
程序计数器 
	作用 记录当前线程执行的位置
	特点:唯一不会发生OutOfMemoryError的区域
java 方法栈
	特点：StackOverFlowError，OutOfMemoryError。是否允许动态扩展，栈深度异常-->StackOverFlowError,内存问题-
 本地方法栈(C栈)
```

https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md

##### 堆 

```
堆可以分为Eden区, from Survior ，to Survivor 老年代

新生代和老年代
	1 新生代：老年代默认1:2, JVM 调参数，XX:NewRatio=2
	2 Eden 空间和另外两个 Survivor 空间缺省所占的比例是：8:1:1
```

##### 对象分配过程

```
new 的对象先放在 Eden 区，大小有限制
如果创建新对象时，Eden 空间填满了，就会触发 Minor GC，将 Eden 不再被其他对象引用的对象进行销毁，再加载新的对象放到 Eden 区，特别注意的是 Survivor 区满了是不会触发 Minor GC 的，而是 Eden 空间填满了，Minor GC 才顺便清理 Survivor 区
将 Eden 中剩余的对象移到 Survivor0 区
再次触发垃圾回收，此时上次 Survivor 下来的，放在 Survivor0 区的，如果没有回收，就会放到 Survivor1 区
再次经历垃圾回收，又会将幸存者重新放回 Survivor0 区，依次类推
默认是 15 次的循环，超过 15 次，则会将幸存者区幸存下来的转去老年区 jvm 参数设置次数 : -XX:MaxTenuringThreshold=N 进行设置
频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集
```

#####  Minor GC /Full GC /Major GC 触发的条件，回收的区域

```
Full GC触发的条件 ：1 显示调用System.gc(),2 老年代的空间不够,3 方法区的空间不够
Full GC特点：停顿时间长，应该避免

```

##### 逃逸分析

```
当一个对象在方法中被定义后，它可能被外部方法所引用，如作为调用参数传递到其他地方中，称为方法逃逸
再如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸

在编译期间，如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。
jvm 参数设置，-XX:+DoEscapeAnalysis ：开启逃逸分析 ，-XX:-DoEscapeAnalysis ： 关闭逃逸分析
从 jdk 1.7 开始已经默认开始逃逸分析。
```



##### TLAB

```
TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区，是属于 Eden 区的，这是一个线程专用的内存分配区域，线程私有,默认开启的（当然也不是绝对的，也要看哪种类型的虚拟机）

堆上申请内存使用CAS,
-XX:+UseTLAB 使用 TLAB,-XX:+TLABSize 设置 TLAB 大小
```

##### 四种引用方式

```
- 强引用：创建一个对象并把这个对象赋给一个引用变量 , 普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收，jvm 即使抛出 OOM，可以将引用赋值为 null，那么它所指向的对象就会被垃圾回收
- 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用
- 弱引用：非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。
- 虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
```

##### 方法区

```
存放：已经被虚拟机加载的类信息 常量 静态变量 即时编译器编译后的代码
特点：线程共享 永久代 内存回收效率低
```



##### 直接内存

```
定义:java虚拟机内存之外的内存
应用：NIO通过 DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率
```

##### 直接内存与堆内存比较

- 直接内存申请空间耗费更高的性能
- 直接内存读取 IO 的性能要优于普通的堆内存。
- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。

##### 怎么看当前使用哪种垃圾收集器

```
-XX:+PrintCommandLineFlags 
通过gc日志
```

常见的jvm配置参数

```
Java 8 为例
**日志**
**1、** -XX:+PrintFlagsFinal，打印JVM所有参数的值
**2、** -XX:+PrintGC，打印GC信息
**3、** -XX:+PrintGCDetails，打印GC详细信息
**4、** -XX:+PrintGCTimeStamps，打印GC的时间戳
**5、** -Xloggc:filename，设置GC log文件的位置
**6、** -XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息
**内存设置**
**1、** -Xms，设置堆的初始化内存大小
**2、** -Xmx，设置堆的最大内存
**3、** -Xmn，设置新生代内存大小
**4、** -Xss，设置线程栈大小
**5、** -XX:NewRatio，新生代与老年代比值
**6、** -XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1
**7、** -XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15
**8、** -XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC
**9、** -XX:MaxMetaspaceSize，元空间最大值
**10、** -XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存
**11、** -XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可
**设置垃圾收集相关**
**1、** -XX:+UseSerialGC，设置串行收集器
**2、** -XX:+UseParallelGC，设置并行收集器
**3、** -XX:+UseConcMarkSweepGC，使用CMS收集器
**4、** -XX:ParallelGCThreads，设置Parallel GC的线程数
**5、** -XX:MaxGCPauseMillis，GC最大暂停时间 ms
**6、** -XX:+UseG1GC，使用G1垃圾收集器
**CMS 垃圾回收器相关**
**1、** -XX:+UseCMSInitiatingOccupancyOnly
**2、** -XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机
**3、** -XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数
**4、** -XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上
**5、** -XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时
**G1 垃圾回收器相关**
**1、** -XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成
**2、** -XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认
**3、** -XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动
**4、** -XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改
```

### 2 hotspot 虚拟机

##### 对象

```
对象头 :
  哈希码
  GC 分代年龄
  锁状态标志
  线程持有的锁
  偏向线程 ID
  偏向时间戳
  如果对象是一个数组，那么对象头还会包括数组长度
 实例数据 父类和本类的成员变量
 对齐数据 确保对象的总长度是8字节的倍数
```

![image-20220225155705041](../images/image-20220225155705041.png)



##### 对象的创建过程

```
1 类加载 
2 分配
	指针碰撞：当内存比较规整，空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大					小一样的距离，这种分配方式称为“指针碰撞”。
	空闲列表： Java 堆中内存并不规整，VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划						分给对象实例。这种方式称为“空闲列表”。
3 初始化 1成员变量初值，设置对象头信息，调用构造函数初始化
```

##### 对象的访问方式

```
内存分配  对象的存储空间都是在堆中分配的，对象的引用却是在堆栈中分配的

句柄访问方式
直接指针访问方式
区别
HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要额外的策略来存储对象在方法区中类信息的地址。
```

![image-20220225162642266](../images/image-20220225162642266.png)

![image-20220225162650101](../images/image-20220225162650101.png)



### 3 垃圾策略和算法

```
1 关注的对象：堆+方法区
```

##### 判断对象是否存活

```
引用计数器;对象头的count计算引用次数，Recycler算法解决循环引用，多线程环境，同步性能低
可达性分析
	所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。
    GC Roots 是指：

    Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
    本地方法栈中引用的对象
    方法区中常量引用的对象
    方法区中类静态属性引用的对象

    GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。
```



##### 引用的种类

```
强引用（Strong Reference）
类似 "Object obj = new Object()" 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们错误地保持了强引用，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。

软引用（Soft Reference）
软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

弱引用（Weak Reference）
弱引用的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。

虚引用（Phantom Reference）
虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。
```

##### 回收方法区内存

```
废弃常量
	判定方式 不被引用
无用的类
	该类的所有对象都已经被清除
  加载该类的 ClassLoader 已经被回收
  该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  
  一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。
```

##### 垃圾收集算法

```
标记-清除
	过程:使用可达性分析标记，清除
	不足：效率问题，标记和清除2个动作效率低;空间问题:碎片
	
复制算法(新生代)
	过程：把内存分为2块，将存货对象复制到另一块，然后清除所有对象。
	优缺点：不会又碎片，但是空间利用率为50%

改进 新生代的内存结构，Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。

问题:不能保证回收的只有10%对象，需要依赖老年代进行分配担保

分配担保
为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。

标记整理-老年代

分代收集
新生代：复制算法
老年代：标记-清除算法、标记-整理算法
```



### 4 hotSpot 垃圾收集器

##### 新生代垃圾收集器

```
Serial 垃圾收集器（单线程） gc时，应用程序会暂停
ParNew 垃圾收集器（多线程）也会有gc停顿

```

##### G1 通用垃圾收集器

```
定义  G1 是一款面向服务端应用的垃圾收集器，它没有新生代和老年代的概念，而是将堆划分为一块块独立的 Region （瑞警）。当要进行垃圾收集时，首先估计每个 Region 中垃圾的数量，每次都从垃圾回收价值最大的 Region 开始回收，因此可以获得最大的回收效率。


Remembered Set 每个Region 都有一个记录引用的set
 G1工作的过程
     初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。
    并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。
    最终标记：Stop The World，使用多条标记线程并发执行。
    筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。
```

### 5 内存分配和回收策略

```
1 对象可能分配在栈 堆 年轻代 老年代上 取决于垃圾回收器的组合和相关参数配置
```

##### 大对象优先分配在Eden(E等)中

```
大多数情况下，对象在新生代 Eden 区中分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。
```

**Minor (ˈmaɪnər) GC** vs **Major(ˈmeɪdʒər) GC**/**Full GC**：

```
新生代：**Minor (ˈmaɪnər) GC
老年代：Major GC  比Minor的慢10倍以上 
```

> 在 JVM 规范中，Major GC 和 Full GC 都没有一个正式的定义，所以有人也简单地认为 Major GC 清理老年代，而 Full GC 清理整个内存堆。



##### 对象直接进入老年代情况

```
1  大对象直接进入老年代  因为大对象发生分配担保的概率很大，分配担保会导致效率低下
-XX:PretenureSizeThreshold 参数配置 大于这个配置称为大对象

2 新生代存活次数超过  XXMaxTenuringThreshold配置 ，进入老年代

3 动态对象年龄判断
	如果当前新生代的 Survivor 中，相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄 >= 该年龄的对象就可以直接进入老年代，无须等到 MaxTenuringThreshold 中要求的年龄。
```



##### 触发jvm full GC 条件

```
1 System.gc()  通过 DisableExplicitGC  参数禁止调用
2 老年代空间不足触发，如果触发后还不足，OutOfMemoryError Java heap space
3 永久代空间不足，方法区空间不足 full gc，触发后还是不足 -->OutOfMemoryError: PermGen space
4 CMS GC是出现promotion failed(担保失败) 和 concurrent mode failure(老年代空间不足)
5 统计得到的 Minor GC 晋升到旧生代的平均大小大于老年代的剩余空间
```

### 6  jvm性能调优

```
对内存如果是14g，full gc 长达十秒
```

##### 场景描述

```
一个小型系统，使用 32 位 JDK，4G 内存，测试期间发现服务端不定时抛出内存溢出异常。 加入 -XX:+HeapDumpOnOutOfMemoryError（添加这个参数后，堆内存溢出时就会输出异常日志）， 但再次发生内存溢出时，没有生成相关异常日志。
```

##### 分析

```
在 32 位 JDK 上，1.6G 分配给堆，还有一部分分配给 JVM 的其他内存，直接内存最大也只能在剩余的 0.4G 空间中分出一部分， 如果使用了 NIO，JVM 会在 JVM 内存之外分配内存空间，那么就要小心“直接内存”不足时发生内存溢出异常了=
```

##### 直接内存的回收过程

```
直接内存虽然不是 JVM 内存空间，但它的垃圾回收也由 JVM 负责。

垃圾收集进行时，虚拟机虽然会对直接内存进行回收， 但是直接内存却不能像新生代、老年代那样，发现空间不足了就通知收集器进行垃圾回收， 它只能等老年代满了后 Full GC，然后“顺便”帮它清理掉内存的废弃对象。 否则只能一直等到抛出内存溢出异常时，先 catch 掉，再在 catch 块里大喊 “`System.gc()`”。 要是虚拟机还是不听，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。
```

### 7 类文件结构

```
Class 文件 中的所有内容被分为两种类型：无符号数、表。
Class 文件具体由以下几个构成:
    魔数
    版本信息
    常量池
    访问标志
    类索引、父类索引、接口索引集合
    字段表集合
    方法表集合
    属性表集合
```



### 8类加载时机

```
类的生命周期：
加载
验证
准备
解析
初始化
使用
卸载

```

##### 初始化规定

主动引用

```
在遇到 new、putstatic、getstatic、invokestatic 字节码指令时，如果类尚未初始化，则需要先触发其初始化。
对类进行反射调用时，如果类还没有初始化，则需要先触发其初始化。
初始化一个类时，如果其父类还没有初始化，则需要先初始化父类。
虚拟机启动时，用于需要指定一个包含 main() 方法的主类，虚拟机会先初始化这个主类。
当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic、	
		REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类还没初始化，则需要先触发其初始化
```

被动引用



##### 接口的加载

```
接口加载过程与类加载过程稍有不同。

当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，当真正用到父接口的时候才会初始化。
```

### 9 类加载过程

类加载过程包括 5 个阶段：加载、验证、准备、解析和初始化。

##### 加载的过程

- ```
  “加载”是“类加载”过程的一个阶段，不能混淆这两个名词。在加载阶段，虚拟机需要完成 3 件事：
  
  - 通过类的全限定名获取该类的二进制字节流。
  - 将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。
  - 在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
  ```

  ##### 获取二进制字节流

  对于 Class 文件，虚拟机没有指明要从哪里获取、怎样获取。除了直接从编译好的 .class 文件中读取，还有以下几种方式：

  - 从 zip 包中读取，如 jar、war 等；
  - 从网络中获取，如 Applet；
  - 通过动态代理技术生成代理类的二进制字节流；
  - 由 JSP 文件生成对应的 Class 类；
  - 从数据库中读取，如 有些中间件服务器可以选择把程序安装到数据库中来完成程序代码在集群间的分发。



##### 验证的过程

- 文件格式验证 验证字节流是否符合 Class 文件格式的规范，并且能被当前版本的虚拟机处理，验证点如下：
  - 是否以魔数 0XCAFEBABE 开头。
  - 主次版本号是否在当前虚拟机处理范围内。
  - 常量池是否有不被支持的常量类型。
  - 指向常量的索引值是否指向了不存在的常量。
  - CONSTANT_Utf8_info 型的常量是否有不符合 UTF8 编码的数据。
  - ......
- 元数据验证 对字节码描述信息进行语义分析，确保其符合 Java 语法规范。
- 字节码验证 本阶段是验证过程中最复杂的一个阶段，是对方法体进行语义分析，保证方法在运行时不会出现危害虚拟机的事件。
- 符号引用验证 本阶段发生在解析阶段，确保解析正常执行。

##### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

### 10 类加载器

##### 判断类是否相等 

```
这里的“相等”，包括代表类的 Class 对象的 equals() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。
```

##### 双亲委派模型是啥 ？如何打破

```
1 打破案例 jdbc tomcat
```

##### 加载器种类

```
系统提供了 3 种类加载器：

启动类加载器（Bootstrap ClassLoader）： 负责将存放在 <JAVA_HOME>\lib 目录中的，并且能被虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。

扩展类加载器（Extension ClassLoader）： 负责加载 <JAVA_HOME>\lib\ext 目录中的所有类库，开发者可以直接使用扩展类加载器。

应用程序类加载器（Application ClassLoader）： 由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，所以一般也称它为“系统类加载器”。它负责加载用户类路径（classpath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。
```

