---
layout: page
---

### 1 基础

##### java代码的运行

```
运行方式：双击jar 命令中运行 网页中 
运行环境 jre，jre包括jvm java核心类库。
运行过程：
```



##### 类的加载过程

```
1 加载，分三步，1 根据包名+类名加载文件二进制文件 2 存储在方法区 3 生成类的class实例
2 验证  文件格式 元数据 字节码 符号引用
3 准备 为静态变量分配内存并设置0值，
4 解析 
5 初始化
```

##### jvm常量池

```
JDK 1.8 开始
**1、** 字符串常量池：存放在堆中，包括 String 对象执行 intern() 方法后存的地方、双引号直接引用的字符串
**2、** 运行时常量池：存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中 constant_pool 的内容
**3、** 类文件常量池：constant_pool，JVM 定义的概念
```

##### java内存模型



![image-20220225110539266](../images/image-20220225110539266.png)

```
方法区
堆
程序计数器 
	作用 记录当前线程执行的位置
	特点:唯一不会发生OutOfMemoryError的区域
java 方法栈
	特点：StackOverFlowError，OutOfMemoryError。是否允许动态扩展，栈深度异常-->StackOverFlowError,内存问题-
 本地方法栈(C栈)
```

https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md

### 2 垃圾回收

##### 怎么看当前使用哪种垃圾收集器

```
-XX:+PrintCommandLineFlags 
通过gc日志
```

##### G1收集器

```
1基于标记-整理算法，不产生内存碎片。
```

##### CMS收集器

```

```

常见的jvm配置参数

```
Java 8 为例
**日志**
**1、** -XX:+PrintFlagsFinal，打印JVM所有参数的值
**2、** -XX:+PrintGC，打印GC信息
**3、** -XX:+PrintGCDetails，打印GC详细信息
**4、** -XX:+PrintGCTimeStamps，打印GC的时间戳
**5、** -Xloggc:filename，设置GC log文件的位置
**6、** -XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息
**内存设置**
**1、** -Xms，设置堆的初始化内存大小
**2、** -Xmx，设置堆的最大内存
**3、** -Xmn，设置新生代内存大小
**4、** -Xss，设置线程栈大小
**5、** -XX:NewRatio，新生代与老年代比值
**6、** -XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1
**7、** -XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15
**8、** -XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC
**9、** -XX:MaxMetaspaceSize，元空间最大值
**10、** -XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存
**11、** -XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可
**设置垃圾收集相关**
**1、** -XX:+UseSerialGC，设置串行收集器
**2、** -XX:+UseParallelGC，设置并行收集器
**3、** -XX:+UseConcMarkSweepGC，使用CMS收集器
**4、** -XX:ParallelGCThreads，设置Parallel GC的线程数
**5、** -XX:MaxGCPauseMillis，GC最大暂停时间 ms
**6、** -XX:+UseG1GC，使用G1垃圾收集器
**CMS 垃圾回收器相关**
**1、** -XX:+UseCMSInitiatingOccupancyOnly
**2、** -XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机
**3、** -XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数
**4、** -XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上
**5、** -XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时
**G1 垃圾回收器相关**
**1、** -XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成
**2、** -XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认
**3、** -XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动
**4、** -XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改
```



##### java中的引用

```
1 强引用 
2 软引用
3 弱引用
4 虚引用
```

