---
layout: page
---

### 1 jvm内存结构

```
面试题 https://github.com/doocs/advanced-java
```



##### java代码的运行

```
运行方式：双击jar 命令中运行 网页中 
运行环境 jre，jre包括jvm java核心类库。
运行过程：
```



##### 类的加载过程

```
1 加载，分三步，1 根据包名+类名加载文件二进制文件 2 存储在方法区 3 生成类的class实例
2 验证  文件格式 元数据 字节码 符号引用
3 准备 为静态变量分配内存并设置0值，
4 解析 
5 初始化
```

##### jvm常量池

```
JDK 1.8 开始
**1、** 字符串常量池：存放在堆中，包括 String 对象执行 intern() 方法后存的地方、双引号直接引用的字符串
**2、** 运行时常量池：存放在方法区，属于元空间，是类加载后的一些存储区域，大多数是类中 constant_pool 的内容
**3、** 类文件常量池：constant_pool，JVM 定义的概念
```

##### jvm内存结构

![image-20220225110539266](../images/image-20220225110539266.png)

```
方法区
堆
程序计数器 
	作用 记录当前线程执行的位置
	特点:唯一不会发生OutOfMemoryError的区域
java 方法栈
	特点：StackOverFlowError，OutOfMemoryError。是否允许动态扩展，栈深度异常-->StackOverFlowError,内存问题-
 本地方法栈(C栈)
```

https://github.com/doocs/jvm/blob/main/docs/01-jvm-memory-structure.md

##### 堆 

```
堆可以分为Eden区, from Survior ，to Survivor 老年代

新生代和老年代
	1 新生代：老年代默认1:2, JVM 调参数，XX:NewRatio=2
	2 Eden 空间和另外两个 Survivor 空间缺省所占的比例是：8:1:1
```

##### 对象分配过程

```
new 的对象先放在 Eden 区，大小有限制
如果创建新对象时，Eden 空间填满了，就会触发 Minor GC，将 Eden 不再被其他对象引用的对象进行销毁，再加载新的对象放到 Eden 区，特别注意的是 Survivor 区满了是不会触发 Minor GC 的，而是 Eden 空间填满了，Minor GC 才顺便清理 Survivor 区
将 Eden 中剩余的对象移到 Survivor0 区
再次触发垃圾回收，此时上次 Survivor 下来的，放在 Survivor0 区的，如果没有回收，就会放到 Survivor1 区
再次经历垃圾回收，又会将幸存者重新放回 Survivor0 区，依次类推
默认是 15 次的循环，超过 15 次，则会将幸存者区幸存下来的转去老年区 jvm 参数设置次数 : -XX:MaxTenuringThreshold=N 进行设置
频繁在新生区收集，很少在养老区收集，几乎不在永久区/元空间搜集
```



##### Full GC /Major GC 触发条件

```
显示调用System.gc(),老年代的空间不够,方法区的空间不够等都会触发 Full GC，同时对新生代和老年代回收，FUll GC 的 STW 的时间最长，应该要避免
在出现 Major GC 之前，会先触发 Minor GC，如果老年代的空间还是不够就会触发 Major GC，STW 的时间长于 Minor GC
```

##### 逃逸分析

```
当一个对象在方法中被定义后，它可能被外部方法所引用，如作为调用参数传递到其他地方中，称为方法逃逸
再如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸

在编译期间，如果 JIT 经过逃逸分析，发现有些对象没有逃逸出方法，那么有可能堆内存分配会被优化成栈内存分配。
jvm 参数设置，-XX:+DoEscapeAnalysis ：开启逃逸分析 ，-XX:-DoEscapeAnalysis ： 关闭逃逸分析
从 jdk 1.7 开始已经默认开始逃逸分析。
```



##### TLAB

```
TLAB 的全称是 Thread Local Allocation Buffer，即线程本地分配缓存区，是属于 Eden 区的，这是一个线程专用的内存分配区域，线程私有,默认开启的（当然也不是绝对的，也要看哪种类型的虚拟机）

堆上申请内存使用CAS,
-XX:+UseTLAB 使用 TLAB,-XX:+TLABSize 设置 TLAB 大小
```

##### 四种引用方式

```
- 强引用：创建一个对象并把这个对象赋给一个引用变量 , 普通 new 出来对象的变量引用都是强引用，有引用变量指向时永远不会被垃圾回收，jvm 即使抛出 OOM，可以将引用赋值为 null，那么它所指向的对象就会被垃圾回收
- 软引用：如果一个对象具有软引用，内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用
- 弱引用：非必需对象，当 JVM 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。
- 虚引用：虚引用并不会决定对象的生命周期，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。
```

##### 方法区

```
存放：已经被虚拟机加载的类信息 常量 静态变量 即时编译器编译后的代码
特点：线程共享 永久代 内存回收效率低
```



##### 直接内存

```
定义:java虚拟机内存之外的内存
应用：NIO通过 DirectByteBuffer对象直接操作该内存，而无须先将外部内存中的数据复制到堆中再进行操作，从而提高了数据操作的效率
```

##### 直接内存与堆内存比较

- 直接内存申请空间耗费更高的性能
- 直接内存读取 IO 的性能要优于普通的堆内存。
- 直接内存作用链： 本地 IO -> 直接内存 -> 本地 IO
- 堆内存作用链：本地 IO -> 直接内存 -> 非直接内存 -> 直接内存 -> 本地 IO

> 服务器管理员在配置虚拟机参数时，会根据实际内存设置`-Xmx`等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制，从而导致动态扩展时出现`OutOfMemoryError`异常。

##### 怎么看当前使用哪种垃圾收集器

```
-XX:+PrintCommandLineFlags 
通过gc日志
```

常见的jvm配置参数

```
Java 8 为例
**日志**
**1、** -XX:+PrintFlagsFinal，打印JVM所有参数的值
**2、** -XX:+PrintGC，打印GC信息
**3、** -XX:+PrintGCDetails，打印GC详细信息
**4、** -XX:+PrintGCTimeStamps，打印GC的时间戳
**5、** -Xloggc:filename，设置GC log文件的位置
**6、** -XX:+PrintTenuringDistribution，查看熬过收集后剩余对象的年龄分布信息
**内存设置**
**1、** -Xms，设置堆的初始化内存大小
**2、** -Xmx，设置堆的最大内存
**3、** -Xmn，设置新生代内存大小
**4、** -Xss，设置线程栈大小
**5、** -XX:NewRatio，新生代与老年代比值
**6、** -XX:SurvivorRatio，新生代中Eden区与两个Survivor区的比值，默认为8，即Eden:Survivor:Survivor=8:1:1
**7、** -XX:MaxTenuringThreshold，从年轻代到老年代，最大晋升年龄。CMS 下默认为 6，G1 下默认为 15
**8、** -XX:MetaspaceSize，设置元空间的大小，第一次超过将触发 GC
**9、** -XX:MaxMetaspaceSize，元空间最大值
**10、** -XX:MaxDirectMemorySize，用于设置直接内存的最大值，限制通过 DirectByteBuffer 申请的内存
**11、** -XX:ReservedCodeCacheSize，用于设置 JIT 编译后的代码存放区大小，如果观察到这个值有限制，可以适当调大，一般够用即可
**设置垃圾收集相关**
**1、** -XX:+UseSerialGC，设置串行收集器
**2、** -XX:+UseParallelGC，设置并行收集器
**3、** -XX:+UseConcMarkSweepGC，使用CMS收集器
**4、** -XX:ParallelGCThreads，设置Parallel GC的线程数
**5、** -XX:MaxGCPauseMillis，GC最大暂停时间 ms
**6、** -XX:+UseG1GC，使用G1垃圾收集器
**CMS 垃圾回收器相关**
**1、** -XX:+UseCMSInitiatingOccupancyOnly
**2、** -XX:CMSInitiatingOccupancyFraction，与前者配合使用，指定MajorGC的发生时机
**3、** -XX:+ExplicitGCInvokesConcurrent，代码调用 System.gc() 开始并行 FullGC，建议加上这个参数
**4、** -XX:+CMSScavengeBeforeRemark，表示开启或关闭在 CMS 重新标记阶段之前的清除（YGC）尝试，它可以降低 remark 时间，建议加上
**5、** -XX:+ParallelRefProcEnabled，可以用来并行处理 Reference，以加快处理速度，缩短耗时
**G1 垃圾回收器相关**
**1、** -XX:MaxGCPauseMillis，用于设置目标停顿时间，G1 会尽力达成
**2、** -XX:G1HeapRegionSize，用于设置小堆区大小，建议保持默认
**3、** -XX:InitiatingHeapOccupancyPercent，表示当整个堆内存使用达到一定比例（默认是 45%），并发标记阶段就会被启动
**4、** -XX:ConcGCThreads，表示并发垃圾收集器使用的线程数量，默认值随 JVM 运行的平台不同而变动，不建议修改
```

### 2 hotspot 虚拟机

##### 对象

```
对象头 :
  哈希码
  GC 分代年龄
  锁状态标志
  线程持有的锁
  偏向线程 ID
  偏向时间戳
  如果对象是一个数组，那么对象头还会包括数组长度
 实例数据 父类和本类的成员变量
 对齐数据 确保对象的总长度是8字节的倍数
```

![image-20220225155705041](../images/image-20220225155705041.png)



##### 对象的创建过程

```
1 类加载 
2 分配
	指针碰撞：当内存比较规整，空闲内存和已使用内存中间放着一个指针作为分界点指示器，那么分配内存时只需要把指针向空闲内存挪动一段与对象大					小一样的距离，这种分配方式称为“指针碰撞”。
	空闲列表： Java 堆中内存并不规整，VM 必须维护一个列表，记录其中哪些内存块空闲可用。分配之时从空闲列表中找到一块足够大的内存空间划						分给对象实例。这种方式称为“空闲列表”。
3 初始化 1成员变量初值，设置对象头信息，调用构造函数初始化
```

##### 对象的访问方式

```
内存分配  对象的存储空间都是在堆中分配的，对象的引用却是在堆栈中分配的

句柄访问方式
直接指针访问方式
区别
HotSpot 采用第二种方式，即直接指针方式来访问对象，只需要一次寻址操作，所以在性能上比句柄访问方式快一倍。但像上面所说，它需要额外的策略来存储对象在方法区中类信息的地址。
```

![image-20220225162642266](../images/image-20220225162642266.png)

![image-20220225162650101](../images/image-20220225162650101.png)



### 3 垃圾策略和算法

```
1 关注的对象：堆+方法区
```

##### 判断对象是否存活

```
引用计数器;对象头的count计算引用次数，Recycler算法解决循环引用，多线程环境，同步性能低
可达性分析
	所有和 GC Roots 直接或间接关联的对象都是有效对象，和 GC Roots 没有关联的对象就是无效对象。
    GC Roots 是指：

    Java 虚拟机栈（栈帧中的本地变量表）中引用的对象
    本地方法栈中引用的对象
    方法区中常量引用的对象
    方法区中类静态属性引用的对象

    GC Roots 并不包括堆中对象所引用的对象，这样就不会有循环引用的问题。
```



##### 引用的种类

```
强引用（Strong Reference）
类似 "Object obj = new Object()" 这类的引用，就是强引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。但是，如果我们错误地保持了强引用，比如：赋值给了 static 变量，那么对象在很长一段时间内不会被回收，会产生内存泄漏。

软引用（Soft Reference）
软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。

弱引用（Weak Reference）
弱引用的强度比软引用更弱一些。当 JVM 进行垃圾回收时，无论内存是否充足，都会回收只被弱引用关联的对象。

虚引用（Phantom Reference）
虚引用也称幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响。它仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制。
```

##### 回收方法区内存

```
废弃常量
	判定方式 不被引用
无用的类
	该类的所有对象都已经被清除
  加载该类的 ClassLoader 已经被回收
  该类的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。
  
  一个类被虚拟机加载进方法区，那么在堆中就会有一个代表该类的对象：java.lang.Class。这个对象在类被加载进方法区时创建，在方法区该类被删除时清除。
```

##### 垃圾收集算法

```
标记-清除
	过程:使用可达性分析标记，清除
	不足：效率问题，标记和清除2个动作效率低;空间问题:碎片
	
复制算法(新生代)
	过程：把内存分为2块，将存货对象复制到另一块，然后清除所有对象。
	优缺点：不会又碎片，但是空间利用率为50%

改进 新生代的内存结构，Eden、From Survivor、To Survivor，比例是 8:1:1，每次使用 Eden 和其中一块 Survivor。回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才使用的 Survivor 空间。这样只有 10% 的内存被浪费。

问题:不能保证回收的只有10%对象，需要依赖老年代进行分配担保

分配担保
为对象分配内存空间时，如果 Eden+Survivor 中空闲区域无法装下该对象，会触发 MinorGC 进行垃圾收集。但如果 Minor GC 过后依然有超过 10% 的对象存活，这样存活的对象直接通过分配担保机制进入老年代，然后再将新对象存入 Eden 区。

标记整理-老年代

分代收集
新生代：复制算法
老年代：标记-清除算法、标记-整理算法
```

