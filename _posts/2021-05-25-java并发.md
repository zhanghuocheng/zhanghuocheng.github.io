---
layout: page
---
java并发



java并发实战

```
volatile 使用场景：某个操作的状态的变化。不能保证count++的原子性

coyponWriteArrayList 替代arrayList

5.0 新增queue blockQueue currentLinkedQueue

blockQueue 如果队列为空，获取元素的线程一致等待。队列满了 put方法将阻塞

6 新增deque 双端对垒  arraydeque  linkedBlockDeque

同步工具类，提供状态，通过状态的改变决定工具类中的线程是执行还是等待

信号量 ：控制同事访问某个资源的数量

线程池类型
固定 有最大值和最小值 默认是linkedblockqueue 队列可以无线增加s
可缓存的  使用的同步移交队列 
单例  默认是linkedblockqueue 队列可以无线增加
定时：可延时或指定时间

默认是linkedblockqueue 队列可以无线增加


队列的类型  有界队列 无界队列 同步移交

cas可能出现的问题 ABA问题 解决办法 加版本号

happens-before：JMM为程序中所有操作定义了一个偏序关系
规则包括：
程序顺序规则：程序中A操作在B操作之前，那么线程A操作将在B操作之前
监视器锁规则：解锁必须在加锁之前
volitale：对volitale的写在读之前
线程启动规则:start方法的调用必须在任何操作之前
线程结束规则：线程所有操作都必须发生在其他线程监测到该线程结束之前。
中断规则:
终结器规则：
传递性：
```

java线程池参数

```

分析一般从几个角度考虑：

1.任务的性质：CPU密集型的任务、IO密集型任务、混合型任务。
2.任务的优先级：高、中、低
3.任务执行时间：长、中、短
4.任务的依赖性：是否依赖其它系统资源，如数据库的连接等。
根据不同的任务可以交给不同规模的线程池执行。

如果是cpu密集型的，尽量减少线程数，如果是IO密集型任务尽量加大线程数，因为io不占用cpu的资源。建议配置2倍CPU个数+1。
如果是混合型的，尽量根据实际情况进行拆分，根据运行时间来决定。
如下为一般计算公式：

最佳线程数目 = （（线程等待时间+线程CPU时间）/线程CPU时间 ）* CPU数目

                       = （线程等待时间与线程CPU时间之比 + 1）* CPU数目

 

线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程

高并发、任务执行时间短的业务怎样使用线程池？并发不高、任务执行时间长的业务怎样使用线程池？并发高、业务执行时间长的业务怎样使用线程池？ 

高并发、任务执行时间短的业务，cpu型线程池线程数可以设置为CPU核数+1，减少线程上下文的切换 
并发不高、任务执行时间长的业务要区分开看： 
假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务 
假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换 
并发高、业务执行时间长，解决这种类型任务的关键不在于线程池而在于整体架构的设计，看看这些业务里面某些数据是否能做缓存是第一步，增加服务器是第二步，至于线程池的设置，设置参考（2）。最后，业务执行时间长的问题，也可能需要分析一下，看看能不能使用中间件对任务进行拆分和解耦。

```

